<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pathSum</title>
      <link href="/2020/07/05/pathSum/"/>
      <url>/2020/07/05/pathSum/</url>
      
        <content type="html"><![CDATA[<p>关于leetcode中路径总和的几道题目的整理。</p><a id="more"></a><h2 id="路径总和I"><a href="#路径总和I" class="headerlink" title="路径总和I"></a>路径总和I</h2><ul><li><p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">leetcode112</a></p></li><li><p>题目描述： 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 </p></li><li><p>解题思路：递归，sum值每次递归减去其根结点的值</p></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        sum -= root.val; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> sum == <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum) || hasPathSum(root.right, sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul><h2 id="路径总和II"><a href="#路径总和II" class="headerlink" title="路径总和II"></a>路径总和II</h2><ul><li><p><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">leetcode113，剑指offer34</a></p></li><li><p>题目描述： 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 </p></li><li><p>解题思路：递归，利用一个数组保存遍历的路径，如果遇到根结点并且满足条件则输出。</p></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        List&lt;Integer&gt; arry = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        dfs(root, sum, arry, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, List&lt;Integer&gt; arry, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        arry.add(root.val);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        sum -= root.val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//ans.add(arry); //整个递归过程用的是同一个arry，需要把当前的状态保存下来，否则最后的输出全为空[]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(arry));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        dfs(root.left, sum, arry, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        dfs(root.right, sum, arry, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        arry.remove(arry.size() - <span class="number">1</span>);<span class="comment">//回溯，去除当前的根结点，继续寻找下一个满足条件的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul><h2 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a>路径总和III</h2><ul><li><p><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">leetcode437</a></p></li><li><p>题目描述：给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p></li><li><p>解题思路：</p><ul><li>思路1：递归，从每一个节点出发，找到所有满足条件的路径，两层递归。</li><li>思路2：考虑到每个节点到根节点的路径是唯一的。用一维数组保存当前节点到根节点的所有路径，用一个标记表示当前路径的终点。</li></ul></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//思路1 双重递归</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//先序遍历每一个结点，在以每一个节点作为起始节点递归查找</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        cal_sum(root, sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        pathSum(root.left, sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        pathSum(root.right, sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//计算当前结点作为根结点的所有满足的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal_sum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        sum -= root.val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            num++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        cal_sum(root.left, sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        cal_sum(root.right, sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="comment">//思路2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**核心：每个节点到根节点的路径是唯一的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * 1.用一维数组保存当前节点到根节点的所有路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * 2.用一个标记表示当前路径的终点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * 3.先序遍历所有节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> cal_sum(root, sum, <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>], <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//arry数组用于保存遍历过的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal_sum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> arry[], <span class="keyword">int</span> p)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> n = (root.val == sum ? <span class="number">1</span> : <span class="number">0</span>); <span class="comment">//判断单独的节点是否满足条件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> cur = root.val; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//根结点出发到当前结点的所有可能值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            cur += arry[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (cur == sum) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                n++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        arry[p] = root.val; <span class="comment">//访问过的结点加入数组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> n1 = cal_sum_2(root.left, sum, arry, p + <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> n2 = cal_sum_2(root.right, sum, arry, p + <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> n + n1 + n2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识图卷积网络</title>
      <link href="/2020/01/08/GCN/"/>
      <url>/2020/01/08/GCN/</url>
      
        <content type="html"><![CDATA[<p>GCN的初学笔记</p><a id="more"></a><p><a href="https://programtip.com/zh/art-45551" target="_blank" rel="noopener">关于卷积神经网络的一些理解</a></p><p><a href="https://www.zhihu.com/question/54504471/answer/332657604" target="_blank" rel="noopener">如何理解 Graph Convolutional Network（GCN）？</a></p><p><a href="https://arxiv.org/pdf/1609.02907.pdf" target="_blank" rel="noopener"> SEMI-SUPERVISED CLASSIFICATION WITH GRAPH CONVOLUTIONAL NETWORKS </a></p><p><a href="https://www.jianshu.com/p/0d27f0816c09" target="_blank" rel="noopener">图神经网络(GCN)</a></p>]]></content>
      
      
      <categories>
          
          <category> GCN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> GCN </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划--子序列和回文串问题</title>
      <link href="/2019/12/15/max-subsequence/"/>
      <url>/2019/12/15/max-subsequence/</url>
      
        <content type="html"><![CDATA[<p>动态规划中关于子序列，回文串的几道题整理了一下。</p><a id="more"></a><h3 id="最长子序列"><a href="#最长子序列" class="headerlink" title="最长子序列"></a>最长子序列</h3><ul><li><p>问题：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p></li><li><p>DP思路：（非最优解）</p><p>记<code>s(i)</code>，<code>t(j)</code>分别为长度为 i，j 的字符串 s 和字符串 t 。</p><p>如果<code>s[i-1]==t[j-1]</code>，最后一位相同，继续比较<code>s[i-2]</code>和<code>t[j-2]</code>，</p><p>如果<code>s[i-1]!=t[j-1]</code>，最后一位不同，比较<code>s[i-1]</code>和<code>t[j-2]</code>，</p><p>使用一个二维数组d保存子序列的状态，</p><p>时间复杂度：<code>O(m*n)</code></p><p>空间复杂度：<code>O(m*n)</code></p></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">boolean</span>[][] d = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">if</span> (s.length() &gt; t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t.length(); j++) &#123; <span class="comment">//s长度为0时，一定是t的子序列</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">              d[<span class="number">0</span>][j] = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.length(); j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                  <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;  <span class="comment">//如果当前的最后一位相同 比较s的前一位和t的前一位</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                      d[i][j] = d[i - <span class="number">1</span>][j - <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                      d[i][j] = d[i][j - <span class="number">1</span>]; <span class="comment">//否则比较s和t的前一位</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">return</span> d[s.length()][t.length()];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="/2019/12/15/max-subsequence/isSubsequence.png" alt></p><p>其他思路参考： <a href="https://github.com/xiaomindog/leetcode/blob/master/java_leetcode/src/com/leetcode/easy/isSubsequence_392.java" target="_blank" rel="noopener">isSubsequence_392</a></p><p>空间复杂度可以继续优化，待更新。</p></li></ul><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><ul><li><p>问题：给定一个字符串 s，找到 s 中最长的回文子串。</p></li><li><p>DP思路：（目前想到的最优解）</p><ul><li><p>中心扩展法</p><p>遍历字符串序列，遍历到第i个字符串，以i字符串为中心，向左右扩展回文串，每次保存最大长度的开始和结束坐标。需要注意的细节是，子串长度为1和2时要单独处理，具体看代码。</p><p>这里中心的个数一般会错误认为是n，实际上是2n-1，因为2个字母中间的空格，在回文子串长度为偶数时是作为中心的。</p><p> 时间复杂度：<code>O(n^2)</code></p><p> 空间复杂度：<code>O(1)</code></p></li></ul></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//按中心展开 共有2n-1个中心 如果字母数为偶数，每2个元素之间的空格也要算为1个中心</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> len1 = expend_from_center(s, i, i); <span class="comment">// 考虑单个字母时候的len</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> len2 = expend_from_center(s, i, i + <span class="number">1</span>); <span class="comment">//考虑2个字母为回文时候的len</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);  <span class="comment">//保存较长的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (len &gt; end - start) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                end = i + len / <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> s.substring(start, end+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//以某个字母向两边扩展</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expend_from_center</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> ((left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            left--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            right++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="/2019/12/15/max-subsequence/longestPalindrome.png" alt></p></li></ul><h3 id="回文子串个数"><a href="#回文子串个数" class="headerlink" title="回文子串个数"></a>回文子串个数</h3><ul><li><p>问题： 给定一个字符串，计算这个字符串中有多少个回文子串。 </p></li><li><p>DP思路：</p><p>中心扩展法，思路同最长回文子串，基本只要加个计数器即可。</p><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(1)</code></p></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length(); i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            count(s, i, i);<span class="comment">//单个字母肯定是回文，只做了一次num++</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            count(s, i, i+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span>(start &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.length() &amp;&amp; s.charAt(start) == s.charAt(end))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            num++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            start--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            end++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="/2019/12/15/max-subsequence/countSubstrings.png" alt></p></li></ul><h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><ul><li><p>问题：给定一个字符串 s，找到其中最长的回文子序列。 </p></li><li><p>DP思路：</p><p>用二维数组<code>dp[n][n]</code>表示长度为 n 的字符串 s 的状态矩阵，<code>dp[i][j]</code>表示 i 到 j 之间字符串最长  回文子序列长度，</p><p>状态转移方程：</p><p>如果 <code>s[i]==s[j]</code>：<code>dp[i][j]=dp[i+1][j-1]+2</code></p><p>如果 <code>s[i]!=s[j]</code>：<code>dp[i][j]=MAX(dp[i+1][j],dp[i][j+1])</code></p><p>注意：i 要从后往前遍历</p><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(n^2)</code></p></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//动态规划 二维数组作为状态矩阵 下三角稀疏 可优化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()][s.length()];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//想清楚为什么从后往前遍历 保证了i,j之间的子序列的状态的更新</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            dp[i][i] = <span class="number">1</span>;<span class="comment">//单个字母的最长回文子序列一定是1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                    dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//输出dp数据测试</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//        for (int i = 0; i &lt; s.length(); i++) &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//            for (int j = 0; j &lt; s.length(); j++) &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//                System.out.print(dp[i][j]);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//            &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//            System.out.println();</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//        &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.length() - <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="/2019/12/15/max-subsequence/longestPalindromeSubseq1.png" alt></p></li><li><p>压缩二维矩阵为一维矩阵，空间复杂度为<code>O(n)</code> 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//二维数据降为一维数组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()]; <span class="comment">// 前一步状态矩阵</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()]; <span class="comment">//当前状态矩阵 最后一个元素永远保存当前的最大回文子序列长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            cur[i] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    cur[j] = pre[j - <span class="number">1</span>] + <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                    cur[j] = Math.max(pre[j], cur[j - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span>[] temp = pre;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            pre = cur;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            cur = temp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> pre[s.length() - <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="/2019/12/15/max-subsequence/longestPalindromeSubseq2.png" alt></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文笔记之HMEAE</title>
      <link href="/2019/12/12/HMEAE/"/>
      <url>/2019/12/12/HMEAE/</url>
      
        <content type="html"><![CDATA[<p>论文地址：<a href="https://www.aclweb.org/anthology/D19-1584.pdf" target="_blank" rel="noopener"> HMEAE: Hierarchical Modular Event Argument Extraction </a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>现有的事件提取方法将每个论元角色独立分类，而忽略了不同论元角色之间的概念相关性。本文提出了事件论元抽取<strong>HMEAE模型</strong>，以从事件论元角色的概念层次结构提供有效的归纳偏差。具体来说，我们为概念层次结构的每个基本单元设计了一个神经模块网络，然后将具有逻辑操作的相关单元模块按层次结构组合到面向规则的模块化网络中，以对特定的论元角色进行分类。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="/2019/12/12/HMEAE/figure1.png" alt></p><p>以图1为例，该论文认为，Seller与Buyer概念上比Seller与Time-within更接近，因为他们在概念层次结构中共享相同的Superordinate Concept ”Person“和”Org“。直观上认为这会提供更多语义信息以提升论元抽取的性能。</p><p>如图1所示，将概念分成2部分：上层概念和下层的细粒度的论元角色。一个论元角色可能属于2个或以上的上层概念。</p><p><img src="/2019/12/12/HMEAE/model.png" alt></p><p>如图2所示，模型主要分成3个部分。1）对于每一个上层概念，实例化上层概念模块（SCM）以突出显示与该概念相关的文本信息；2）然后，对于每个论元角色，由其特定角色的逻辑联合模块组成与其上位概念相对应的SCM，以获得统一的高级模块；3）最后，根据高级模块的输出设置参数角色分类器，以预测实体是否属于给定的论元角色。</p><h3 id="Instance-Encoder"><a href="#Instance-Encoder" class="headerlink" title="Instance Encoder"></a>Instance Encoder</h3><p>将句子表示成n个词的序列，x={w1,…t,…,a,…,wn}，t表示触发词，a是候选论元。触发词在ED工作中已经识别出，与EAE任务相互独立。</p><h4 id="Sentence-Encoder"><a href="#Sentence-Encoder" class="headerlink" title="Sentence Encoder"></a>Sentence Encoder</h4><p>将单词序列编码为隐藏层表示，{h1,h2,…,hn} = E(w1,,…t,…,a,…,wn)，E(.)是对句子进行编码的神经网络。本文采用CNN和BERT作为编码器。</p><h4 id="Feature-Aggregator"><a href="#Feature-Aggregator" class="headerlink" title="Feature Aggregator"></a>Feature Aggregator</h4><p>特征聚合器将隐层向量聚合到一个实例向量中，延用DMCNN的方法。<a href="https://www.jianshu.com/p/84fd666b1900" target="_blank" rel="noopener">DMCNN</a></p><h3 id="Hierarchical-Modular-Attention"><a href="#Hierarchical-Modular-Attention" class="headerlink" title="Hierarchical Modular Attention"></a>Hierarchical Modular Attention</h3><p>上层概念模块会给每个隐藏的嵌入提供一个Attention分数，与其相关性建模。</p><h4 id="Superordinate-Concept-Module"><a href="#Superordinate-Concept-Module" class="headerlink" title="Superordinate Concept Module"></a>Superordinate Concept Module</h4><p>上层概念模块，对于特定的上层概念c，我们用可训练的向量Uc表示其语义特征。 采用多层感知器来计算注意力得分。 首先计算隐藏状态，=========(3)。<a href="https://www.aclweb.org/anthology/D15-1166.pdf" target="_blank" rel="noopener">参考论文</a> <a href="https://www.jianshu.com/p/1c24eba3ba9c" target="_blank" rel="noopener">论文笔记</a></p><p>再通过softmax计算获得隐层的Attention分数，=====(4)其中Wa和Wb是在不同上层概念模块之间共享的可训练  矩阵。</p><h4 id="Logic-Union-Module"><a href="#Logic-Union-Module" class="headerlink" title="Logic Union Module"></a>Logic Union Module</h4><p>给定论元角色r∈R，我们将其k个上层概念表示为c1,c2,…ck。，ck和hi的相应注意力得分由(4)计算。由于应将所有上层概念的信息保留在面向角色的嵌入中，因此我们将注意力得分的平均值计算为面向角色的注意力得分(5)。</p><p>然后计算隐层embedding的加权总和作为面向论元角色的embedding。</p><h3 id="Argument-Role-Classifier"><a href="#Argument-Role-Classifier" class="headerlink" title="Argument Role Classifier"></a>Argument Role Classifier</h3><p>将实例词嵌入x和面向角色的嵌入e^r串联起来作为论元角色分类器的输入特征，并估算实例x的r属于R的概率，其中r是论元角色r的embedding。</p><h3 id="Overall-Evaluation-Results"><a href="#Overall-Evaluation-Results" class="headerlink" title="Overall Evaluation Results"></a>Overall Evaluation Results</h3><p><img src="/2019/12/12/HMEAE/result.png" alt></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>上层概念模块有8类：[Person,Place,Org,Time,Good,Behavior,Entity,NA]。</p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo如何在不同电脑上写博客</title>
      <link href="/2019/12/08/hexo%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E4%B8%8A%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/12/08/hexo%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E4%B8%8A%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>如果要更换电脑了发现电脑里没有原来的博客文件怎么办，这时候就可以利用git的分支保存我们博客的相关文件，每次更新都上传到分支去，更换电脑只需git clone下来即可。</p><a id="more"></a><h3 id="上传分支"><a href="#上传分支" class="headerlink" title="上传分支"></a>上传分支</h3><ul><li><p>先在github博客仓库中创建一个分支，在<code>settings</code>中设置<code>hexo</code>分支为默认分支，仓库克隆至本地目录</p></li><li><p>复制原来第一次写博客配置的那些文件（除了<code>.deploy_git</code>）。注意，需要把theme目录下的<code>.git</code>文件删除。</p></li><li><p>把配置相关内容上传博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">git add . </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">git commit -m "add hexo branch"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">git push</span></pre></td></tr></table></figure><p>这一步如果出现错误<code>warning: LF will be replaced by CRLF</code>，可在该目录下添加文件<code>.gitattributes</code>文件，内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># Auto detect text files and perform LF normalization</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">*        text&#x3D;auto</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">*.cs     text diff&#x3D;csharp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">*.java   text diff&#x3D;java</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">*.html   text diff&#x3D;html</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">*.css    text</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">*.js     text</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">*.sql    text</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">*.csproj text merge&#x3D;union</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">*.sln    text merge&#x3D;union eol&#x3D;crlf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">*.docx   diff&#x3D;astextplain</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">*.DOCX   diff&#x3D;astextplain</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"># absolute paths are ok, as are globs</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#x2F;**&#x2F;postinst* text eol&#x3D;lf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"># paths that don&#39;t start with &#x2F; are treated relative to the .gitattributes folder</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">relative&#x2F;path&#x2F;*.txt text eol&#x3D;lf</span></pre></td></tr></table></figure><p>具体细节参考：<a href="![img](file:///C:\Users\cm\AppData\Roaming\Tencent\QQ\Temp%W@GJ$ACOF(TYDYECOKVDYB.png)https://stackoverflow.com/questions/170961/whats-the-best-crlf-carriage-return-line-feed-handling-strategy-with-git">使用git最好的CRLF（回车，换行处理策略是什么？）</a>，stackoverflow需翻墙，应该可以成功，如果不行尝试其他办法吧。</p></li></ul><h3 id="更换电脑后操作"><a href="#更换电脑后操作" class="headerlink" title="更换电脑后操作"></a>更换电脑后操作</h3><ul><li><p>安装原来需要的环境，创建github链接等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git</span></pre></td></tr></table></figure><p>这条命令执行完后目录中会生成node_modules和public文件夹，这是原来上传的时候忽略上传的内容</p></li><li><p>然后可以开始正常写博客了，<code>hexo n &quot;XXX&quot;</code></p></li><li><p>注意：</p><p>如果更新了博客的配置，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">git add . </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  git commit -m "modify xxx"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  git push</span></pre></td></tr></table></figure><p>更新博客配置到GitHub上以备份。</p></li></ul><h3 id="设置SSH使用hexo-d时免输用户名密码"><a href="#设置SSH使用hexo-d时免输用户名密码" class="headerlink" title="设置SSH使用hexo d时免输用户名密码"></a>设置SSH使用hexo d时免输用户名密码</h3><ul><li>参考：( <a href="https://blog.csdn.net/hhgggggg/article/details/77853665" target="_blank" rel="noopener">https://blog.csdn.net/hhgggggg/article/details/77853665</a> )</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于kashgari+BERT的命名实体识别（NER）</title>
      <link href="/2019/12/06/%E5%9F%BA%E4%BA%8Ekashgari-BERT%E7%9A%84%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB%EF%BC%88NER%EF%BC%89/"/>
      <url>/2019/12/06/%E5%9F%BA%E4%BA%8Ekashgari-BERT%E7%9A%84%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB%EF%BC%88NER%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近帮师兄做NER的BIO标注进行触发词识别的对比实验，用到了一个很好的框架<a href="https://github.com/BrikerMan/Kashgari" target="_blank" rel="noopener">kashgari</a>，基于 tf.keras编写，使用起来很方便，几分钟即可搭建一个文本分类/命名实体识别的baseline。对于命名实体识别任务，该框架封装了BiLSTM，BiGRU，BiLSTM+CRF，BiGRU+CRF，CNN_LSTM。可加载wordembedding和bert词向量。</p><a id="more"></a><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">pip install tensorflow&#x3D;&#x3D;1.14</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">pip install kashgari-tf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">python3.6</span></pre></td></tr></table></figure><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>NER标签采用BIO标注的形式。</p><p>train_x和 train_y，test_x和test_y都是list类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">train_x: [[char1],[char1],[char1],..... ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">train_y: [[label1],[label2],[label3],..... ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#eg:bert基于字级别的BIO数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">train_x = [[<span class="string">'立'</span>,<span class="string">'法'</span>,<span class="string">'院'</span>,<span class="string">'成'</span>,<span class="string">'立'</span>,<span class="string">'刺'</span>,<span class="string">'激'</span>,<span class="string">'团'</span>,<span class="string">'体'</span>],...]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">train_y = [[<span class="string">'B-ORG'</span>,<span class="string">'I-ORG'</span>,<span class="string">'I-ORG'</span>,<span class="string">'O'</span>,<span class="string">'O'</span>,<span class="string">'O'</span>,<span class="string">'O'</span>,<span class="string">'O'</span>,<span class="string">'O'</span>],...]</span></pre></td></tr></table></figure><h3 id="导入模型，加载预训练embedding"><a href="#导入模型，加载预训练embedding" class="headerlink" title="导入模型，加载预训练embedding"></a>导入模型，加载预训练embedding</h3><p><a href="https://github.com/google-research/bert" target="_blank" rel="noopener">BERT-Base, Chinese</a></p><p><a href="https://github.com/Embedding/Chinese-Word-Vectors" target="_blank" rel="noopener">Chinese-Word-Vectors</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kashgari</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kashgari.tasks.labeling <span class="keyword">import</span> BiLSTM_CRF_Model, BiGRU_CRF_Model</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kashgari.embeddings <span class="keyword">import</span> BERTEmbedding, WordEmbedding</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">BERT_PATH = <span class="string">'./data/chinese_L-12_H-768_A-12'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">bert_embedding=BERTEmbedding(BERT_PATH,task=kashgari.LABELING,sequence_length=<span class="number">100</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果加载wordembedding的词向量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#word_embedding = WordEmbedding(embed_path, task=kashgari.LABELING, sequence_length=100)</span></span></pre></td></tr></table></figure><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">model = BiLSTM_CRF_Model(embedding)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">model.fit(train_x, train_y,x_validate=val_x, y_validate=val_y,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">          epochs=<span class="number">40</span>,batch_size=<span class="number">128</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果没有开发集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#model.fit(train_x, train_y,epochs=40,batch_size=128)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">model.evaluate(test_x, test_y)</span></pre></td></tr></table></figure><h3 id="实验结果及代码"><a href="#实验结果及代码" class="headerlink" title="实验结果及代码"></a>实验结果及代码</h3><p>实验证明BERT+BiLSTM+CRF取得的效果是最好的。完整代码待上传github。</p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> NER </tag>
            
            <tag> bert </tag>
            
            <tag> kashgari </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人博客</title>
      <link href="/2019/12/06/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/12/06/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>搭建简易的hexo博客过程，一些自己常用设置和相关操作</p><a id="more"></a><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><ul><li>git</li><li>nodejs</li><li>hexo</li><li>创建github同名的仓库</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li><p><code>hexo init</code> hexo自动下载一些文件到目录</p></li><li><p><code>hexo g</code> 生成静态文件  hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github上</p></li><li><p><code>hexo s</code> 本地预览 打开浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到内容，<code>Ctrl+C</code>停止本地预览</p></li><li><p>设置主题 打开_config.yml 找到theme字段： 添加主题next</p></li><li><p>配置站点配置文件_config.yml deploy的部分. 安装部署插件  <code>npm install hexo-deployer-git</code>  <code>hexo d</code> 部署到github上 最后打开即可显示内容</p></li></ul><h3 id="主题相关配置"><a href="#主题相关配置" class="headerlink" title="主题相关配置"></a>主题相关配置</h3><ul><li><p>主题风格 ：编辑schemes字段。 更新主题风格 <code>hexo clean,hexo g, hexo d</code></p></li><li><p>设置Menu：编辑menu字段。</p></li><li><p>修改文章内链接文本样式：themes/next/source/css/_common/components/post/post.styl，在末尾添加CSS样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  color: #0593d3; //原始链接颜色</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  border-bottom: 1px solid #0593d3; //底部分割线颜色</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    color: #fc6423; //鼠标经过颜色</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    border-bottom: 1px solid #fc6423; //底部分割线颜色</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li><li><p>设置头像：编辑url字段 添加图片链接</p></li><li><p>社交栏：编辑social字段 <code>[社交平台名]: [社交地址] || [图标名称]</code></p></li><li><p>设置首页不显示全文(只显示预览)：markdown文本中添加<code>&lt;!--more--&gt;</code></p></li><li><p>分类和标签设置 <code>hexo new page &quot;name&quot;</code>  可在yourBlog\source\“name”\index.md继续编辑内容</p><p>scaffolds/post.md文件下可设置新建文件的模板</p></li><li><p>搜索功能：待添加</p></li><li><p>修改分类标签样式：<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 # 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p></li><li><p>菜单栏图标设置：<a href="https://icomoon.io/#preview-essential" target="_blank" rel="noopener">icomoon</a>找到想要的图标即可</p></li><li></li></ul><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
