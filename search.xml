<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>xgboost面试题整理</title>
      <link href="/2021/06/22/xgb-qa/"/>
      <url>/2021/06/22/xgb-qa/</url>
      
        <content type="html"><![CDATA[<p>xgboost面试问题整理！</p><a id="more"></a><h3 id="什么是gbdt？"><a href="#什么是gbdt？" class="headerlink" title="什么是gbdt？"></a>什么是gbdt？</h3><p>GBDT（Gradient Boosting Decision Tree）是一种迭代的决策树算法，该算法由多棵决策树组成，它是属于 Boosting 策略。GBDT 由三个概念组成：Regression Decision Tree（即 DT）、Gradient Boosting（即 GB），和 Shrinkage（一个重要演变）。<strong>GBDT 的核心在于累加所有树的结果作为最终结果，所以 GBDT 中的树都是回归树，不是分类树</strong> ， GBDT 的每一棵树都是以之前树得到的<strong>残差</strong>来更新目标值，这样每一棵树的值加起来即为 GBDT 的预测值。而<strong>残差其实是最小均方损失函数关于预测值的反向梯度。</strong>也就是说，预测值和实际值的残差与损失函数的负梯度相同，但是基于残差的GBDT 容易对异常值敏感，所以回归类的损失函数一般为： <strong>绝对损失或者 Huber 损失函数</strong></p><p><strong>GBDT 的每一步残差计算其实变相地增大了被分错样本的权重，而对于分对样本的权重趋于 0</strong> 。</p><p><strong>Shrinkage思想</strong>：在GBDT中，Shrinkage仍以残差为学习的目标，但对于残差学习的结果只累加一小部分， 来逐渐逼近目标，从而有一种渐变的效果，Shrinkage会为每棵树设置一个weight权重（可以再附加学习率来控制渐变情况），通过乘以权重进行渐进。</p><h3 id="什么是xgboost？"><a href="#什么是xgboost？" class="headerlink" title="什么是xgboost？"></a>什么是xgboost？</h3><p>xgboost是一种boosting集成学习方法，它的核心思想就是不断地添加树，<strong>不断地进行特征分裂来生长一棵树，每次添加一个树，其实是学习一个新函数，去拟合上次预测的残差</strong>。当训练完成得到k棵树，我们要预测一个样本的分数，其实就是根据这个样本的特征，在每棵树中会落到对应的一个叶子节点，每个叶子节点就对应一个分数，最后只需要将每棵树对应的分数加起来就是该样本的预测值。</p><p>它主要的创新在于：</p><ul><li><p><strong>对损失函数进行了二阶泰勒展开，同时使用一阶二阶导数</strong></p></li><li><p><strong>加入正则项控制模型的复杂度</strong>（正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和，正则项降低了模型的variance）</p></li></ul><h3 id="xgboost相比gbdt的优化？"><a href="#xgboost相比gbdt的优化？" class="headerlink" title="xgboost相比gbdt的优化？"></a>xgboost相比gbdt的优化？</h3><ul><li><p>算法本身的优化：首先GBDT只支持决策树，Xgboost除了支持决策树，可以支持多种弱学习器，可以是默认的gbtree, 也就是CART决策树，还可以是线性弱学习器gblinear以及DART；其次GBDT损失函数化简的时候进行的是一阶泰勒公式的展开，而Xgboost使用的是二阶泰勒公式的展示。还有一点是Xgboost的目标函数加上了正则项，这个正则项是对树复杂度的控制，防止过拟合。</p></li><li><p><strong>可以处理缺失值</strong>。尝试通过枚举所有缺失值在当前节点是进入左子树，还是进入右子树更优来决定一个处理缺失值默认的方向</p></li><li><p>运行效率：<strong>并行化</strong>，单个弱学习器最耗时的就是决策树的分裂过程，对于不同特征的特征分裂点，可以使用多线程并行选择。我自己理解，这里应该针对的是每个节点，而不是每个弱学习器。</p></li><li><p>从最优化的角度来看:</p><p>GBDT采用的是数值优化的思维, 用的最速下降法去求解Loss Function的最优解, 其中用CART决策树去拟合负梯度, 用牛顿法求步长.</p><p>XGboost用的解析的思维, 对Loss Function展开到二阶近似, 求得解析解, 用解析解作为Gain来建立决策树, 使得Loss Function最优.</p></li></ul><h3 id="Xgboost用泰勒二阶展开的原因？"><a href="#Xgboost用泰勒二阶展开的原因？" class="headerlink" title="Xgboost用泰勒二阶展开的原因？"></a>Xgboost用泰勒二阶展开的原因？</h3><p>Xgboost官网上有说，当目标函数是MSE时，展开是一阶项（残差）+二阶项的形式，而其他目标函数，如logloss的展开式就没有这样的形式。为了能有个统一的形式，所以采用泰勒展开来得到二阶项，这样就能把MSE推导的那套直接复用到其他自定义损失函数上。简短来说，就是为了<strong>统一损失函数求导的形式以支持自定义损失函数</strong>。这是从<strong>为什么会想到引入泰勒二阶</strong>的角度来说的。而且泰勒的本质是尽量去模仿一个函数，猜<strong>二阶泰勒展开已经足以近似大量损失函数</strong>。</p><p>二阶信息本身就能让梯度收敛更快更准确。这一点在优化算法里的<strong>牛顿法</strong>里已经证实了。可以简单认为一阶导指引梯度方向，二阶导指引梯度方向如何变化。这是从二阶导本身的性质，也就是<strong>为什么要用泰勒二阶展开</strong>的角度来说的。</p><p><a href="https://www.zhihu.com/question/277638585/answer/522272201" target="_blank" rel="noopener">为什么xgboost泰勒二阶展开后效果就比较好了呢？</a></p><p><a href="https://zhuanlan.zhihu.com/p/83999508" target="_blank" rel="noopener">牛顿法和二阶泰勒展开的关系</a></p><h3 id="xgboost的目标函数优化问题？"><a href="#xgboost的目标函数优化问题？" class="headerlink" title="xgboost的目标函数优化问题？"></a>xgboost的目标函数优化问题？</h3><p>LR可以通过SGD来优化，xgboost是一个<strong>离散型的优化问题</strong>。</p><p>1.近似目标函数，引入二阶泰勒</p><p>2.把树的结构参数化引入到目标函数</p><p>3.贪心算法/近似算法优化</p><h3 id="xgboost的优缺点？"><a href="#xgboost的优缺点？" class="headerlink" title="xgboost的优缺点？"></a>xgboost的优缺点？</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><strong>精度更高：</strong>GBDT 只用到一阶泰勒展开，而 XGBoost 对损失函数进行了二阶泰勒展开。XGBoost 引入二阶导一方面是为了增加精度，另一方面也是为了能够自定义损失函数，<strong>二阶泰勒展开可以近似大量损失函数</strong>；</li><li><strong>灵活性更强：</strong>GBDT 以 CART 作为基分类器，XGBoost 不仅支持 CART 还支持线性分类器，（使用线性分类器的 XGBoost 相当于带 L1 和 L2 正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题））。此外，XGBoost 工具支持自定义损失函数，只需函数支持一阶和二阶求导；</li><li><strong>正则化：</strong>XGBoost 在目标函数中加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、叶子节点权重的 L2 范式。正则项降低了模型的方差，使学习出来的模型更加简单，有助于防止过拟合；</li><li><strong>Shrinkage（缩减）：</strong>相当于学习速率。XGBoost 在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间；</li><li><strong>列抽样：</strong>XGBoost 借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算；</li><li><strong>缺失值处理：</strong>XGBoost 采用的稀疏感知算法极大的加快了节点分裂的速度；</li><li><strong>可以并行化操作：</strong>块结构可以很好的支持并行计算。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>虽然利用预排序和近似算法可以降低寻找最佳分裂点的计算量，但在节点分裂过程中仍需要遍历数据集；</li><li>预排序过程的空间复杂度过高，不仅需要存储特征值，还需要存储特征对应样本的梯度统计值的索引，相当于消耗了两倍的内存。</li></ol><h3 id="基于决策树的xgboost的时间复杂度？"><a href="#基于决策树的xgboost的时间复杂度？" class="headerlink" title="基于决策树的xgboost的时间复杂度？"></a>基于决策树的xgboost的时间复杂度？</h3><p>决策树的复杂度可由叶子数 <img src="https://www.zhihu.com/equation?tex=T" alt="[公式]"> 组成，叶子节点越少模型越简单，此外叶子节点也不应该含有过高的权重 <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> （类比 LR 的每个变量的权重），所以目标函数的正则项可以定义为：</p><p><img src="https://www.zhihu.com/equation?tex=%5COmega%28f_t%29%3D%5Cgamma+T+%2B+%5Cfrac12+%5Clambda+%5Csum_%7Bj%3D1%7D%5ET+w_j%5E2+%5C%5C" alt="[公式]"></p><p>即决策树模型的复杂度由生成的所有决策树的叶子节点数量，和所有节点权重所组成的向量的 <img src="https://www.zhihu.com/equation?tex=L_2" alt="[公式]"> 范式共同决定。</p><h3 id="如何计算每个特征的分裂收益呢？"><a href="#如何计算每个特征的分裂收益呢？" class="headerlink" title="如何计算每个特征的分裂收益呢？"></a>如何计算每个特征的分裂收益呢？</h3><p>假设我们在某一节点完成特征分裂，则分列前的目标函数可以写为：</p><p><img src="https://www.zhihu.com/equation?tex=Obj_%7B1%7D+%3D-%5Cfrac12+%5B%5Cfrac%7B%28G_L%2BG_R%29%5E2%7D%7BH_L%2BH_R%2B%5Clambda%7D%5D+%2B+%5Cgamma++%5C%5C" alt="[公式]"></p><p>分裂后的目标函数为：</p><p><img src="https://www.zhihu.com/equation?tex=Obj_2+%3D++-%5Cfrac12+%5B+%5Cfrac%7BG_L%5E2%7D%7BH_L%2B%5Clambda%7D+%2B+%5Cfrac%7BG_R%5E2%7D%7BH_R%2B%5Clambda%7D%5D+%2B2%5Cgamma+%5C%5C" alt="[公式]"></p><p>则对于目标函数来说，分裂后的收益为：</p><p><strong>0.5*(左子树分数+右子树分数-不分割可以得到的分数)-加入新节点引入的复杂度的代价</strong></p><p><img src="https://www.zhihu.com/equation?tex=Gain%3D%5Cfrac12+%5Cleft%5B+%5Cfrac%7BG_L%5E2%7D%7BH_L%2B%5Clambda%7D+%2B+%5Cfrac%7BG_R%5E2%7D%7BH_R%2B%5Clambda%7D+-+%5Cfrac%7B%28G_L%2BG_R%29%5E2%7D%7BH_L%2BH_R%2B%5Clambda%7D%5Cright%5D+-+%5Cgamma+%5C%5C" alt="[公式]"></p><p>注意该特征收益也可作为特征重要性输出的重要依据。</p><h3 id="在决策树的生长过程中，如何找到叶子的节点的最优切分点？"><a href="#在决策树的生长过程中，如何找到叶子的节点的最优切分点？" class="headerlink" title="在决策树的生长过程中，如何找到叶子的节点的最优切分点？"></a>在决策树的生长过程中，如何找到叶子的节点的最优切分点？</h3><ul><li><p>贪心算法</p><ol><li>从深度为0的树开始，对每个叶节点枚举所有的可用特征；</li><li>针对每个特征，把属于该节点的训练样本根据该特征值进行升序排列，通过线性扫描的方式来决定该特征的最佳分裂点，并记录该特征的分裂收益；</li><li>选择收益最大的特征作为分裂特征，用该特征的最佳分裂点作为分裂位置，在该节点上分裂出左右两个新的叶节点，并为每个新节点关联对应的样本集</li><li>回到第 1 步，递归执行到满足特定条件为止</li></ol></li><li><p>近似算法</p><p>贪婪算法可以的到最优解，但当数据量太大时则无法读入内存进行计算，近似算法主要针对贪婪算法这一缺点给出了近似最优解。该算法会首先根据特征分布的<strong>分位数</strong>提出候选<strong>划分点</strong>，然后将连续型特征映射到由这些候选点划分的桶中，然后聚合统计信息找到所有区间的最佳分裂点。</p><p>XGBoost在寻找splitpoint的时候，不会枚举所有的特征值，而会对特征值进行聚合统计，按照<strong>特征值的密度分布</strong>，构造直方图计算特征值分布的面积，然后划分分布形成若干个bucket(桶)，每个bucket的面积相同，将<strong>bucket边界上的特征值</strong>作为splitpoint的候选，<strong>遍历所有的候选分裂点</strong>来找到最佳分裂点。</p><p>XGBoost 不是简单地按照样本个数进行分位，而是<strong>以二阶导数值 <img src="https://www.zhihu.com/equation?tex=h_i+" alt="[公式]">作为样本的权重进行划分</strong>（通过目标函数推导而来）。</p></li></ul><h3 id="xgboost如何处理数据缺失？"><a href="#xgboost如何处理数据缺失？" class="headerlink" title="xgboost如何处理数据缺失？"></a>xgboost如何处理数据缺失？</h3><p>XGBoost 在构建树的节点过程中<strong>只考虑非缺失值的数据遍历，而为每个节点增加了一个缺省方向，</strong>当样本相应的特征值缺失时，可以被归类到缺省方向上，最优的缺省方向可以从数据中学到。至于如何学到缺省值的分支，其实很简单，分别枚举特征缺省的样本归为左右分支后的增益，选择增益最大的枚举项即为最优缺省方向。</p><h3 id="xgboost的块结构实现，为什么能够并行计算？"><a href="#xgboost的块结构实现，为什么能够并行计算？" class="headerlink" title="xgboost的块结构实现，为什么能够并行计算？"></a>xgboost的块结构实现，为什么能够并行计算？</h3><p>决策树的学习最耗时的一个步骤就是在每次寻找最佳分裂点是都需要对特征的值进行排序。而 XGBoost 在训练之前对根据特征对数据进行了排序，然后保存到<strong>块结构</strong>中，并在每个块结构中都采用了<strong>稀疏矩阵</strong>存储格式进行存储，后面的训练过程中会重复地使用块结构，可以大大减小计算量。</p><ul><li>每一个块结构包括一个或多个已经排序好的特征；</li><li>缺失特征值将不进行排序；</li><li>每个特征会存储指向样本梯度统计值的索引，方便计算一阶导和二阶导数值；</li></ul><p>这种块结构存储的特征之间相互独立，方便计算机进行并行计算。在对节点进行分裂时需要选择增益最大的特征作为分裂，这时各个特征的增益计算可以同时进行，这也是 Xgboost 能够实现分布式或者多线程计算的原因。</p><h3 id="xgboost分别是如何处理二分类和多分类问题的？"><a href="#xgboost分别是如何处理二分类和多分类问题的？" class="headerlink" title="xgboost分别是如何处理二分类和多分类问题的？"></a>xgboost分别是如何处理二分类和多分类问题的？</h3><p>XGBoost 用 gbtree 做基分类器的话是用每次迭代构建一棵回归树，每棵树都是二叉树，二分类问题就看对应落到哪个叶子节点上，最后用加法模型算出最终的结果。</p><p>XGboost用于分类时用logloss损失函数，因为在使用提升树一类算法（包括XGboost）求损失函数的极值的时候，我们需要用到牛顿法、梯度下降法等方法。logloss损失函数的优点是可以求一阶导数，二阶导数来应用牛顿法，梯度下降法等方法去最小化损失函数。</p><p>xgboost多分类速度慢。</p><h3 id="xgboost特征的重要性是如何评估的？"><a href="#xgboost特征的重要性是如何评估的？" class="headerlink" title="xgboost特征的重要性是如何评估的？"></a>xgboost特征的重要性是如何评估的？</h3><ul><li><strong>weight</strong> ：该特征在所有树中被用作分割样本的特征的总次数。</li><li><strong>gain</strong> ：该特征在其出现过的所有树中产生的平均增益（我自己的理解就是目标函数减少值总和的平均值，这里也可以使用增益之和）。</li><li><strong>cover</strong> ：该特征在其出现过的所有树中的平均覆盖范围。</li></ul><p>这里有一个细节需要注意，就是节点分割的时候，之前用过的特征在当前节点也是可以使用的，所以<code>weight</code>才是有意义的。</p><h3 id="xgboost抑制过拟合的方式？"><a href="#xgboost抑制过拟合的方式？" class="headerlink" title="xgboost抑制过拟合的方式？"></a>xgboost抑制过拟合的方式？</h3><p>行采样：行采样是bagging的思想,每次只抽取部分样本进行训练,不使用全部的样本,可以增加树的多样性。</p><p>列采样：随机森林的思想，相当于在做<strong>随机特征筛选</strong>，进入模型的特征个数越少(即模型变量越少)，模型越简单，根据机器学习理论（方差偏差理论），模型越简单，模型泛化性越好</p><p>shrinkage：XGBoost 在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间</p><p>参数：树的深度，树个数，最小信息增益，最大装箱数，每个节点的最少样本数。</p><h3 id="xgboost为什么要用负梯度拟合残差？"><a href="#xgboost为什么要用负梯度拟合残差？" class="headerlink" title="xgboost为什么要用负梯度拟合残差？"></a>xgboost为什么要用负梯度拟合残差？</h3><p>首先，残差实际上默认是<strong>损失函数为MSE平方损失下的真实值和某一轮模型预测值的差值即 yi - f(xi)</strong>。其实这个是对平方损失函数求导之后的结果，也就是说<strong>在平方损失下求完导，他的负梯度就是残差</strong>。因为Loss的正梯度是上升的方向，负梯度是下降的方向。在传统的LR等Model中，训练的时候是用梯度下降来尽可能逼近Loss的近似最优值，所以在Boosting里面，也是通过沿着负梯度不断拟合这个值来使得整体的偏差尽可能的沿着Loss最小的方向走。</p><h3 id="xgboost相比nn模型的优势？"><a href="#xgboost相比nn模型的优势？" class="headerlink" title="xgboost相比nn模型的优势？"></a>xgboost相比nn模型的优势？</h3><p>1.可解释性强</p><h3 id="xgboost代码调参"><a href="#xgboost代码调参" class="headerlink" title="xgboost代码调参"></a>xgboost代码调参</h3><p>框架参数：</p><ul><li>booster：弱学习器类型</li><li>objective：分类还是回归问题以及对应的损失函数</li><li>n_estimators：弱学习器的个数</li></ul><p>弱学习器参数：</p><ul><li>max_depth：树的深度</li><li>min_child_weight：最小节点的权重阈值，小于这个值，节点不会再分裂；</li><li>gamma：节点分裂带来损失最小阈值，我们使用目标函数之差计算增益，小于这个阈值的时候，不再分裂</li><li>learning_rate:控制每个弱学习器的权重缩减系；这个系数会乘以叶子节点的权重值，它的作用在于削弱每个树的影响力，如果学习率小，对应的弱学习器的个数就应该增加。</li></ul><h3 id="xgboost增量训练？"><a href="#xgboost增量训练？" class="headerlink" title="xgboost增量训练？"></a>xgboost增量训练？</h3><h3 id="xgboost树模型的特征怎么做？"><a href="#xgboost树模型的特征怎么做？" class="headerlink" title="xgboost树模型的特征怎么做？"></a>xgboost树模型的特征怎么做？</h3><h3 id="LightGBM"><a href="#LightGBM" class="headerlink" title="LightGBM"></a>LightGBM</h3><p>LightGBM 为了解决XGBoost 的缺点提出了以下几点解决方案：</p><ol><li>单边梯度抽样算法；</li><li>直方图算法；</li><li>互斥特征捆绑算法；</li><li>基于最大深度的 Leaf-wise 的垂直生长算法；</li><li>类别特征最优分割；</li><li>特征并行和数据并行；</li><li>缓存优化。</li></ol><ul><li><p><strong>单边梯度抽样算法</strong></p><p>GBDT 算法的梯度大小可以反应样本的权重，梯度越小说明模型拟合的越好，单边梯度抽样算法保留了梯度大的样本，并对梯度小的样本进行随机抽样，为了不改变样本的数据分布，在计算增益时为梯度小的样本引入一个常数进行平衡。</p></li><li><p><strong>直方图算法</strong></p><p>直方图算法的基本思想是将连续的特征离散化为 k 个离散特征，同时构造一个宽度为 k 的直方图用于统计信息（含有 k 个 bin）。利用直方图算法我们无需遍历数据，只需要遍历 k 个 bin 即可找到最佳分裂点。</p><p>优势：内存占用小，计算代价小。</p><p>虽然将特征离散化后无法找到精确的分割点，可能会对模型的精度产生一定的影响，但较粗的分割也起到了正则化的效果，一定程度上降低了模型的方差。</p></li><li><p><strong>带深度限制的 Leaf-wise 算法</strong></p><ul><li><strong>Level-wise：基于层进行生长，直到达到停止条件；</strong></li><li><strong>Leaf-wise：每次分裂增益最大的叶子节点，直到达到停止条件。</strong></li></ul><p>XGBoost 采用 Level-wise 的增长策略，方便并行计算每一层的分裂节点，提高了训练速度，但同时也因为节点增益过小增加了很多不必要的分裂，降低了计算量；LightGBM 采用 Leaf-wise 的增长策略减少了计算量，配合最大深度的限制防止过拟合，由于每次都需要计算增益最大的节点，所以无法并行分裂。</p></li><li><p><strong>LightGBM 相对于 XGBoost 的优点，内存和速度</strong></p><ul><li><strong>内存更小</strong></li></ul><ol><li>XGBoost 使用预排序后需要记录特征值及其对应样本的统计值的索引，而 LightGBM 使用了直方图算法将特征值转变为 bin 值，且不需要记录特征到样本的索引，将空间复杂度从 <img src="https://www.zhihu.com/equation?tex=O%282%2A%5C%23data%29" alt="[公式]"> 降低为 <img src="https://www.zhihu.com/equation?tex=O%28%5C%23bin%29" alt="[公式]"> ，极大的减少了内存消耗；</li><li>LightGBM 采用了直方图算法将存储特征值转变为存储 bin 值，降低了内存消耗；</li><li>LightGBM 在训练过程中采用互斥特征捆绑算法减少了特征数量，降低了内存消耗。</li></ol><ul><li><strong>速度更快</strong></li></ul><ol><li>LightGBM 采用了直方图算法将遍历样本转变为遍历直方图，极大的降低了时间复杂度；</li><li>LightGBM 在训练过程中采用单边梯度算法过滤掉梯度小的样本，减少了大量的计算；</li><li>LightGBM 采用了基于 Leaf-wise 算法的增长策略构建树，减少了很多不必要的计算量；</li><li>LightGBM 采用优化后的特征并行、数据并行方法加速计算，当数据量非常大的时候还可以采用投票并行的策略；</li><li>LightGBM 对缓存也进行了优化，增加了Cache hit的命中率。</li></ol></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/148050748" target="_blank" rel="noopener">一篇文章搞定GBDT、Xgboost和LightGBM的面试</a></p><p><a href="https://zhuanlan.zhihu.com/p/87885678" target="_blank" rel="noopener">【机器学习】决策树（下）——XGBoost、LightGBM（非常详细）</a></p><p><a href="https://zhuanlan.zhihu.com/p/34534004" target="_blank" rel="noopener">ID3、C4.5、CART、RF、boosting、Adaboost、GBDT、xgboost模型</a></p><p><a href="https://www.bilibili.com/video/BV1si4y1G7Jb?p=1" target="_blank" rel="noopener">XGBoost的技术剖析</a></p><p><a href="https://zhuanlan.zhihu.com/p/142817461" target="_blank" rel="noopener">一文搞定XGboost 面试常见问题</a></p>]]></content>
      
      
      <categories>
          
          <category> xgboost </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集成学习 </tag>
            
            <tag> xgboost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>word2vec-and-fastText</title>
      <link href="/2021/06/22/word2vec-and-fastText/"/>
      <url>/2021/06/22/word2vec-and-fastText/</url>
      
        <content type="html"><![CDATA[<p>整理word2vec和fasttext的原理。</p><a id="more"></a><h2 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h2><p>word2vec主要包括Skip-Gram和CBOW两种模型。</p><p>Skip-Gram是利用一个词语作为输入，来预测它周围的上下文 ，CBOW是利用一个词语的上下文作为输入，来预测这个词语本身 。</p><h3 id="简单情形"><a href="#简单情形" class="headerlink" title="简单情形"></a>简单情形</h3><p>输入：one-hot encoder</p><p>隐层：对输入的词求和取平均+线性层</p><p>输出：隐层</p><p><strong>word2vec的本质：</strong>是一种<strong>降维</strong>操作——把词语从 one-hot encoder 形式的表示降维到 Word2vec 形式的表示，是一个|V|分类问题。</p><p><strong>训练目标：</strong> 极小化负对数似然 </p><p>   <strong>Tip：</strong> CBOW的窗口内部丢掉了词序信息，但是在窗口滑动过程中是按照通顺的自然语言顺序滑动的，或者样本就是按照一定的语序取出来的，所以最终得出的词向量中会包含一定的语序信息。</p><h3 id="Word2vec-的训练trick"><a href="#Word2vec-的训练trick" class="headerlink" title="Word2vec 的训练trick"></a>Word2vec 的训练trick</h3><p> Word2vec 本质上是一个语言模型，它的输出节点数是 V 个，对应了 V 个词语，本质上是一个多分类问题，但实际当中，词语的个数非常非常多，会给计算造成很大困难，所以需要用技巧来加速训练。 </p><ul><li><p><strong>Word pairs and “phase”</strong>: 对常见的单词进行组合或者词组作为单个words来处理（比如<code>&quot;New York&quot;</code>,<code>&quot;United Stated&quot;</code>）</p></li><li><p><strong>高频词采样：</strong>对高频词进行抽样来减少训练样本的个数（比如<code>the</code>这个词在很多次的窗口中出现吗，他对其他词语义学习的帮助不大，并且，更多包含<code>the</code>的训练数据远远超出了学习<code>the</code>这个词向量所需要的样本数）</p></li><li><p><strong>负采样：</strong>用来提高训练速度并且改善所得到词向量的质量 。</p><p>随机选取部分词作为负样本（比如当vocab_size为10000时，训练样本 <code>input word:&quot;fox&quot;,output word:&quot;quick&quot;</code> ,在9999个负样本的权重中选择5-20个更新，参数大大减少）。</p><ul><li><p>如何选择negative words？</p><p>根据词频进行负采样，出现概率高的单词容易被选为负样本。 每个单词被赋予一个权重。    </p><script type="math/tex; mode=display">P(w_i)=\frac{f(w_i)^{3/4}}{\sum^n_{j=0}(f(w_i)^{3/4})}</script></li><li><p><strong>层次softmax（Hierarchical Softmax）</strong></p><p>在进行最优化的求解过程中：从隐藏层到输出的Softmax层的计算量很大，因为要计算所有词的Softmax概率，再去找概率最大的值。 </p><p>word2vec采用了<strong>霍夫曼树</strong>来代替从隐藏层到输出softmax层的映射 。</p><p>和之前的神经网络语言模型相比，霍夫曼树的所有内部节点就类似之前神经网络隐藏层的神经元,其中，根节点的词向量对应我们的投影后的词向量，而所有叶子节点就类似于之前神经网络softmax输出层的神经元，叶子节点的个数就是词汇表的大小。在霍夫曼树中，隐藏层到输出层的softmax映射不是一下子完成的，而是沿着霍夫曼树一步步完成的，因此这种softmax取名为 <strong>Hierarchical Softmax</strong> 。 </p><p>在word2vec中，我们采用了二元逻辑回归的方法，即规定沿着左子树走，那么就是负类(霍夫曼树编码1)，沿    着右子树走，那么就是正类(霍夫曼树编码0)。判别正类和负类的方法是使用sigmoid函数， 采用随机梯度上升求解二分类，每计算一个样本更新一次误差函数 。</p><p><strong>使用霍夫曼树有什么好处：</strong></p></li></ul></li></ul><p>​        首先，由于是二叉树，之前计算量为<code>V</code>,现在变成了<code>log2V</code>。</p><p>​        第二，由于使用霍夫曼树是<strong>高频的词靠近树根</strong>，这样高频词需要更少的时间会被找到，这符合贪心优化思想。         </p><h2 id="fasttext"><a href="#fasttext" class="headerlink" title="fasttext"></a>fasttext</h2><p>fasttext是基于浅层神经网络训练的，其训练方式与word2vec中的CBOW方式如出一辙，fasttext是对整个句子的n-gram特征相加求平均，得到句向量，在根据句向量做分类。        </p><p>fasttext的输入：embedding过的单词的词向量和n-gram向量        </p><p>内存考虑：<strong>哈希映射</strong>，将n-gram映射到固定K个的索引上，相同的索引共享相同的embedding。</p><h2 id="fasttext与word2vec对比"><a href="#fasttext与word2vec对比" class="headerlink" title="fasttext与word2vec对比"></a>fasttext与word2vec对比</h2><ul><li>fasttext用作分类是有监督的，word2vec是无监督的</li><li>fasttext输入部分考虑了n-gram特征，word2vec的输入只有one-hot encoder</li><li>fasttext可以表示oov的单词</li></ul><p>word2vec的不足：</p><ol><li>多义词的问题。</li><li>Word2vec 是一种静态的方式，无法针对特定任务做动态优化</li></ol><p>fasttext的不足：</p><p>fastText很难学出词序对句子语义的影响，对复杂任务还是需要用复杂网络学习任务的语义表达。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/" target="_blank" rel="noopener">Word2Vec Tutorial - The Skip-Gram Model</a></p><p><a href="https://zhuanlan.zhihu.com/p/26306795" target="_blank" rel="noopener">秒懂词向量Word2vec的本质</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于面试中的python细节</title>
      <link href="/2021/04/04/python-details/"/>
      <url>/2021/04/04/python-details/</url>
      
        <content type="html"><![CDATA[<p>python面试常见问题总结。</p><a id="more"></a><h3 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h3><ol><li><p>动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明。</p></li><li><p>python中一切皆对象。</p></li></ol><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ol><li>Python利用<strong>内存池机制</strong>用于管理小块内存的申请和释放；</li><li>当创建大量占用内存小的对象时，即频繁调用new/malloc，会导致大量内存碎片，致使效率降低，所以需要内存池机制。</li><li>内存池机制需要在内存中预先申请一定数量的、大小相同的内存块留作备用，当有新的内存需求时，先从内存池中，给这个需求分配内存，如果不够了，就在重新申请。</li></ol><h3 id="列表和字典的底层原理"><a href="#列表和字典的底层原理" class="headerlink" title="列表和字典的底层原理"></a>列表和字典的底层原理</h3><ul><li><p>列表</p><p>Python中的列表是<strong>由对其它对象的引用组成的连续数组</strong>。指向这个数组的指针及其长度被保存在一个列表头结构中。这意味着，每次添加或删除一个元素时，由引用组成的数组需要该标大小（重新分配）。幸运的是，Python在创建这些数组时采用了指数分配，所以并不是每次操作都需要改变数组的大小。</p></li><li><p>字典</p><p> CPython使用<strong>伪随机探测</strong>（ 取随机数来作为步长 ）的<strong>散列表</strong>作为字典的底层数据结构。由于这个实现细节，只有<strong>可哈希的</strong>对象才能作为字典的键。 </p></li></ul><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p> python利用<strong>引用计数</strong>实现跟踪和回收垃圾，并在引用计数的基础上，使用<strong>“标记-删除”</strong>解决容器内部对象的循环引用问题，利用<strong>分代回收</strong>以空间换取时间进一步提高垃圾回收的效率。 </p><ul><li>引用计数<br>当一个对象的引用被创建或者复制时，对象的引用计数+1；<br>当一个对象的引用被销毁时，对象的引用计数-1；<br>当对象的引用计数为0时，表明这个对象不会再被使用，将其内存释放掉。</li><li>标记-删除<br>寻找根对象的集合来作为垃圾检测动作的起点，根对象的集合是全局变量的引用或者函数栈的引用，这些引用所指向的对象不可能被删除；从根对象出发，沿着根对象集合的每个引用，如果某个对象能够到达，就说明这个对象是可达的，可达对象是不会被删除的，这个过程就是垃圾检测阶段；垃圾检测结束之后，所有对象被分为可达和不可达，可达对象被保留，释放所有不可达对象的内存，这就是垃圾回收阶段。</li><li>分代回收<br>将系统中所有内存快按其存活时间划分为多个集合，也就是“代”，python默认定义了三代对象集合，活得越久的对象越不可能是垃圾，应该减少对它的垃圾收集频率。<br>如何衡量“活得越久”：这个对象经过的垃圾收集次数。</li></ul><h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><ul><li><p>迭代器</p><ul><li>迭代器生成，被迭代一遍之后，里面的元素就被取光了，如果想在用，还得重新生成。</li><li>迭代器从集合的第一个元素来开始访问，直到访问完所有的元素，只能向前，不能后退。</li></ul></li><li><p>生成器</p><ul><li><p><strong>生成器函数：</strong>常规函数定义，但是，使用<strong>yield</strong>语句而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次重它离开的地方继续执行。</p></li><li><p><strong>生成器表达式：</strong>类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表。一个生成器表达式的例子: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)] <span class="comment"># 列表推导式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">squares = (x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)) <span class="comment"># 生成器表达式</span></span></pre></td></tr></table></figure></li></ul></li></ul><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p> 装饰器是一种函数的函数，因为装饰器传入的参数就是一个函数，然后通过实现各种功能来对这个函数的功能进行增强。</p><p>装饰器最大的优势是用于解决重复性的操作，其主要使用的场景有如下几个：</p><ul><li>计算函数运行时间</li><li>给函数打日志</li><li>类型检查</li></ul><p><a href="https://www.zhihu.com/question/325817179/answer/798679602" target="_blank" rel="noopener">如何更通俗地讲解Python的装饰器？</a></p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li>GIL（Global Interpreter Lock，全局解释器锁） </li></ul><p>待更新…</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统入门</title>
      <link href="/2021/04/02/Recommendation-system/"/>
      <url>/2021/04/02/Recommendation-system/</url>
      
        <content type="html"><![CDATA[<p>  推荐系统一般分为2个部分，召回、粗排、精排、重排。本文是对推荐系统的一个入门学习。</p><a id="more"></a><p>对比推荐和NLP，我认为NLP更像是偏底层的技术， <strong>推荐系统的问题抽象之后和NLP问题非常相似。</strong></p><p> 推荐系统的基本问题可以抽象成求解 </p><script type="math/tex; mode=display">p(item_i|user, history\_item_1, history\_item_2, ... history\_item_k)</script><p>即求解指定 item在指定user的历史行为记录下可能产生行为的<strong>联合条件概率</strong>，其中item, history_item的形式都是item id。 </p><p> 而NLP的language model中，第k个word的概率也正是类似的形式。</p><script type="math/tex; mode=display">p(w_i|w_{i-1}, w_{i-2}, ... w_1)</script><p>工业界推荐系统一般包含四个部分：召回、粗排、精排、重排（召回和排序）。下面分别了解一下。</p><h3 id="召回"><a href="#召回" class="headerlink" title="召回"></a>召回</h3><p> 召回阶段负责从海量数据中快速筛选出部分数据，供后面排序阶段使用。 </p><ul><li><p>召回模型</p><ul><li><p>基于协同过滤的召回算法</p><p> 基于用户相似性推荐的叫UserCF，基于物品相似度推荐的叫ItemCF </p></li><li><p>基于矩阵分解的召回算法</p><p>SVD  <strong>奇异值分解</strong> </p></li><li><p>Embedding 召回</p><p>one-hot —&gt; word2vec —&gt; Node2vec —&gt; bert</p></li></ul></li><li><p>经典模型</p><p>DSSM 文本匹配</p></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li><p>模型</p><ul><li><p>LR</p><p>lr是比较简单的线性模型，通过学习用户点击行为来构建CTR（ 点击通过率 ）预估。</p></li><li><p>GBDT+LR</p></li></ul></li><li><p>效果评估</p><ol><li>离线评估</li><li>线上实验</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统，实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xgboost</title>
      <link href="/2021/04/02/Xgboost/"/>
      <url>/2021/04/02/Xgboost/</url>
      
        <content type="html"><![CDATA[<p> Xgboost在面试中被问到过很多次，因为没有实践过，只有一些浅显的理论理解。</p><a id="more"></a><h3 id="核心算法思想"><a href="#核心算法思想" class="headerlink" title="核心算法思想"></a>核心算法思想</h3><ol><li>不断地添加树，不断地进行特征分裂来生长一棵树，每次添加一个树，其实是学习一个新函数<strong>f(x)</strong>，去拟合上次预测的<strong>残差</strong>（ <strong>A的实际值 - A的预测值 = A的残差</strong> ）。</li><li>当我们训练完成得到k棵树，我们要预测一个样本的分数，其实就是根据这个样本的特征，在每棵树中会落到对应的一个叶子节点，每个叶子节点就对应一个分数</li><li>最后只需要将每棵树对应的分数加起来就是该样本的预测值。</li></ol><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>事实上，如果不考虑工程实现、解决问题上的一些差异，xgboost与gbdt比较大的不同就是目标函数的定义。 </p><p> 目标函数分为两部分：<strong>损失函数和正则化项</strong>。   <strong>损失函数揭示训练误差，正则化定义复杂度</strong> </p><ul><li>损失函数</li></ul><p><img src="/2021/04/02/Xgboost/obj.png" alt="avatar"></p><p>​         考虑到我们的第t 颗回归树是根据前面的t-1颗回归树的残差得来的，相当于t-1颗树的值yi^(t-1)是已知的。换句话说，L(yi,yi^(t-1))对目标函数的优化不影响，可以直接去掉，且常数项也可以移除，从而得到如下一个比较统一的目标函数。 <img src="/2021/04/02/Xgboost/obj2.png" alt="avatar"></p><p>​    <strong>目标函数只依赖于每个数据点在误差函数上的一阶导数<img src="https://private.codecogs.com/gif.la        tex?g" alt="g">和二阶导数<img src="https://private.codecogs.com/gif.latex?h" alt="h"> </strong></p><ul><li><p>正则项</p><p>xgboost对树的复杂度包含了两个部分：</p><ol><li>一个是树里面叶子节点的个数T</li><li>一个是树上叶子节点的得分w的L2模平方（对w进行L2正则化）</li></ol></li></ul><h3 id="打分函数"><a href="#打分函数" class="headerlink" title="打分函数"></a>打分函数</h3><p><img src="/2021/04/02/Xgboost/obj3.png" alt="avatar"></p><ul><li><p>分裂节点</p><ul><li><p>枚举所有不同树结构的贪心法 </p><p><strong>先按照该特征里的值进行排序，然后线性扫描该特征进而确定最好的分割点</strong>，最后对所有特征进行分割后，我们选择所谓的增益Gain最高的那个特征 。</p><p><img src="/2021/04/02/Xgboost/gain.png" alt="avatar" style="zoom:80%;"></p></li><li><p>近似算法（ 针对数据太大，不能直接进行计算 ）</p><p>总而言之，XGBoost使用了和CART回归树一样的想法，利用贪婪算法，遍历所有特征的所有特征划分点，不同的是使用的目标函数不一样。具体做法就是分裂后的目标函数值比单子叶子节点的目标函数的增益，同时为了限制树生长过深，还加了个阈值，只有当增益大于该阈值才进行分裂。 </p></li></ul></li></ul><h3 id="Xgboost与GBDT的不同"><a href="#Xgboost与GBDT的不同" class="headerlink" title="Xgboost与GBDT的不同"></a>Xgboost与GBDT的不同</h3><ul><li>GBDT是机器学习算法，XGBoost是该算法的工程实现。</li><li>在使用CART作为基分类器时，XGBoost显式地加入了<strong>正则项</strong>来控制模型的复杂度，有利于防止过拟合，从而提高模型的泛化能力。</li><li>GBDT在模型训练时只使用了代价函数的<strong>一阶导数</strong>信息，XGBoost对代 价函数进行<strong>二阶泰勒展开</strong>，可以同时使用<strong>一阶和二阶导数</strong>。</li><li>传统的GBDT采用<strong>CART</strong>作为基分类器，XGBoost支持多种类型的基分类器，比如线性分类器。</li><li>传统的GBDT在每轮迭代时使用全部的数据，XGBoost则采用了与随机森林相似的策略，支持对数据进行采样。</li><li>传统的GBDT没有设计对缺失值进行处理，XGBoost能够自动学习出缺失值的处理策略。</li></ul><h3 id="为什么XGBoost要用泰勒展开，优势在哪里？"><a href="#为什么XGBoost要用泰勒展开，优势在哪里？" class="headerlink" title="为什么XGBoost要用泰勒展开，优势在哪里？"></a>为什么XGBoost要用泰勒展开，优势在哪里？</h3><p> XGBoost使用了一阶和二阶偏导, 二阶导数有利于梯度下降的更快更准。使用泰勒展开取得函数做自变量的二阶导数形式，可以在不选定损失函数具体形式的情况下，仅仅依靠输入数据的值就可以进行叶子分裂优化计算，本质上也就把损失函数的选取和模型算法优化/参数选择分开了。这种去耦合增加了XGBoost的适用性，使得它按需选取损失函数，可以用于分类，也可以用于回归。 </p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>泰勒公式：</p><p><img src="/2021/04/02/Xgboost/tale.png" alt="avatar"></p><p> 其中的多项式称为函数在a 处的泰勒展开式，剩余的Rn(x)是泰勒公式的余项，是(x-a)^n的高阶无穷小 </p><ul><li><p>参考</p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/81410574" target="_blank" rel="noopener">通俗理解kaggle比赛大杀器xgboost</a></p><p><a href="https://zhuanlan.zhihu.com/p/87885678" target="_blank" rel="noopener">【机器学习】决策树（下）——XGBoost、LightGBM（非常详细）</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 决策树 </tag>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集成学习</title>
      <link href="/2021/04/02/Ensemble-learning/"/>
      <url>/2021/04/02/Ensemble-learning/</url>
      
        <content type="html"><![CDATA[<p> 常见的集成学习框架有三种：Bagging，Boosting 和 Stacking。三种集成学习框架在基学习器的产生和综合结果的方式上会有些区别，做一些整理。</p><a id="more"></a><h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><p> 每个基学习器基于<strong>不同子训练集进行训练</strong>，并综合所有基学习器的预测值得到最终的预测结果。Bagging 常用的综合方法是投票法，票数最多的类别为预测类别。 </p><h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><p> Boosting 训练过程为阶梯状，基模型的训练是有顺序的，每个基模型都会在前一个基模型学习的基础上进行学习，最终综合所有基模型的预测值产生最终的预测结果，用的比较多的综合方式为加权法。 </p><h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><p> Stacking 是先用全部数据训练好n个基模型，然后每个基模型都对每个训练样本进行的预测，其预测值将作为训练样本的特征值，最终会得到新的训练样本，然后基于新的训练样本进行训练得到模型，然后得到最终预测结果。 </p><h3 id="集成学习的偏差与方差"><a href="#集成学习的偏差与方差" class="headerlink" title="集成学习的偏差与方差"></a>集成学习的偏差与方差</h3><p> 偏差（Bias）描述的是预测值和真实值之差；方差（Variance）描述的是预测值作为随机变量的离散程度。 </p><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>  用随机的方式建立一个森林。RF 算法由很多决策树组成，每一棵决策树之间没有关联。建立完森林后，当有新样本进入时，每棵决策树都会分别进行判断，然后基于投票法给出分类结果。 </p><ul><li>算法流程<ul><li>随机选择样本（放回抽样）；</li><li>随机选择特征；</li><li>构建决策树；</li><li>随机森林投票（平均）。</li></ul></li><li><p>优点</p><ul><li>在数据集上表现良好，相对于其他算法有较大的优势</li><li>易于并行化，在大数据集上有很大的优势；</li><li>能够处理高维度数据，不用做特征选择。</li></ul><p>随机采样由于引入了两种采样方法保证了随机性，所以每棵树都是最大可能的进行生长就算不剪枝也不会出现过拟合。 </p></li></ul><h3 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h3><p> AdaBoost（Adaptive Boosting，自适应增强），其自适应在于：<strong>前一个基本分类器分错的样本会得到加强，加权后的全体样本再次被用来训练下一个基本分类器。同时，在每一轮中加入一个新的弱分类器，直到达到某个预定的足够小的错误率或达到预先指定的最大迭代次数。</strong> </p><p>Adaboost 模型是加法模型，学习算法为前向分步学习算法，损失函数为指数函数的分类问题。</p><p><strong>加法模型</strong>：最终的强分类器是由若干个弱分类器加权平均得到的。</p><p><strong>前向分布学习算法</strong>：算法是通过一轮轮的弱学习器学习，利用前一个弱学习器的结果来更新后一个弱学习器的训练集权重。</p><ul><li><p>算法步骤</p><ul><li><p>初始化训练样本的权值分布，每个样本具有相同权重；</p></li><li><p>训练弱分类器，如果样本分类正确，则在构造下一个训练集中，它的权值就会被降低；反之提高。用更新过的样本集去训练下一个分类器；</p></li><li><p>将所有弱分类组合成强分类器，各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，降低分类误差率大的弱分类器的权重。</p></li></ul></li><li><p>优点</p><ol><li>分类精度高；</li><li>可以用各种回归分类模型来构建弱学习器，非常灵活；</li><li>不容易发生过拟合。</li></ol></li><li><p>缺点</p><p>​     对异常点敏感，异常点会获得较高权重。 </p></li></ul><h3 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h3><p> GBDT（Gradient Boosting Decision Tree）是一种迭代的决策树算法，该算法由多棵决策树组成，它是属于 Boosting 策略。GBDT 是被公认的泛化能力较强的算法。 </p><p><strong>GBDT 的核心在于累加所有树的结果作为最终结果，所以 GBDT 中的树都是回归树，不是分类树 </strong>， GBDT 的每一棵树都是以之前树得到的<strong>残差</strong>来更新目标值，这样每一棵树的值加起来即为 GBDT 的预测值。 </p><p> 整体模型为迭代式 ：<img src="/2021/04/02/Ensemble-learning/gbdt.svg" alt="avatar"></p><p> 每一轮迭代中，只要集中解决一个基模型的训练问题：使 <img src="https://www.zhihu.com/equation?tex=F_k%28x%29" alt="[公式]"> 逼近真实值 <img src="https://www.zhihu.com/equation?tex=y" alt="[公式]"> 。</p><p>损失函数为： <strong>绝对损失或者 Huber 损失函数</strong> </p><p> <strong>GBDT 的每一步残差计算其实变相地增大了被分错样本的权重，而对与分对样本的权重趋于 0</strong> 。</p><ul><li>优点<ul><li>可以自动进行特征组合，拟合非线性数据；</li><li>可以灵活处理各种类型的数据。</li></ul></li><li>缺点<ul><li>对异常点敏感。</li></ul></li><li>与Adaboost相比<ul><li>都是 Boosting 家族成员，使用弱分类器；</li><li>都使用前向分布算法。</li><li><strong>迭代思路不同</strong>：Adaboost 是通过提升错分数据点的权重来弥补模型的不足（利用错分样本），而 GBDT 是通过算梯度来弥补模型的不足（利用残差）；</li><li><strong>损失函数不同</strong>：AdaBoost 采用的是指数损失，GBDT 使用的是绝对损失或者 Huber 损失函数；</li></ul></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/86263786" target="_blank" rel="noopener">【机器学习】决策树（中）——Random Forest、Adaboost、GBDT （非常详细）</a></p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集成学习 </tag>
            
            <tag> 决策树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大似然估计与最大后验估计（贝叶斯估计）</title>
      <link href="/2021/04/01/MLE-and-MAP/"/>
      <url>/2021/04/01/MLE-and-MAP/</url>
      
        <content type="html"><![CDATA[<p> 最大似然估计(Maximum Likelihood Estimation)与最大后验估计(Maximum A Posteriori)是机器学习中最常用的两种<strong>参数估计方法</strong>(统计领域问题： 已知数据，推模型和参数 )。 最大似然估计可以认为是<strong>频率学派</strong>的观点，最大后验概率估计可以认为是<strong>贝叶斯学派</strong>的观点。 </p><h3 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h3><ul><li>最大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。</li><li>最大似然估计假设数据都是<strong>独立同分布</strong>的。</li><li>最大化P(x0|θ)</li></ul><h3 id="最大后验估计"><a href="#最大后验估计" class="headerlink" title="最大后验估计"></a>最大后验估计</h3><ul><li>最大化 <em>P</em>(θ∣x0)=P(x0∣θ)P(θ) / P(x0) 贝叶斯公式  P(θ|x0) 即后验概率</li></ul><h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><ul><li><p>最大似然估计，是通过给定观测值，需要获得参数，使得多组观测值出现的概率最大化。最大后验估计，在给定观测值的同时，给出参数的先验分布，通过先验和似然并且利用贝叶斯公式得最大后验。</p></li><li><p><strong>MAP 考虑了模型的先验分布，而MLE 假设模型是均匀分布，即先验概率P(θ)=1。</strong> 可以说，MLE是MAP的一种特例 </p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/u011508640/article/details/72815981?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control" target="_blank" rel="noopener">详解最大似然估计（MLE）、最大后验概率估计（MAP），以及贝叶斯公式的理解</a></p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小的K个数的多种解法</title>
      <link href="/2021/04/01/topK/"/>
      <url>/2021/04/01/topK/</url>
      
        <content type="html"><![CDATA[<p>最小的k个数在面试中遇到了4次，记录一下多种解法。</p><a id="more"></a><h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><ul><li>初始版本<ul><li>时间复杂度最坏情况下O(NlogN)</li><li>空间复杂度O(logN)</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr, k)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :type arr: List[int]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :type k: int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :rtype: List[int]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">0</span> <span class="keyword">or</span> k &gt; len(arr): <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>: <span class="keyword">return</span> []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        self.quickSort(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> arr[:k]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(self, arr, i, j, k)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> i &gt; j: <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        p = self.partition(arr, i, j)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> p == k:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">elif</span> p &gt; k:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            self.quickSort(arr, i, p - <span class="number">1</span>, k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            self.quickSort(arr, p + <span class="number">1</span>, j, k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, arr, i, j)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># if i &gt;= j: return i</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        pivot = arr[i]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> i &lt; j:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt;= pivot:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                j -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            arr[i] = arr[j]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;= pivot:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">                i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            arr[j] = arr[i]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        arr[i] = pivot</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> i</span></pre></td></tr></table></figure><ul><li><p>优化版本</p><p><strong>三数取中的方法优化选取枢轴</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, arr, i, j)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        mid = (i + j) &gt;&gt; <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> arr[i] &gt; arr[j]:  <span class="comment"># 把小的放到i上去</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> arr[mid] &gt; arr[j]:  <span class="comment"># 把最大的放到最后去</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            arr[mid], arr[j] = arr[j], arr[mid]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> arr[mid] &gt; arr[i]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            arr[mid], arr[i] = arr[i], arr[mid]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        pivot = arr[i]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> i &lt; j:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt;= pivot:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                j -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            arr[i] = arr[j]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;= pivot:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            arr[j] = arr[i]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        arr[i] = pivot</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> i</span></pre></td></tr></table></figure></li></ul><h2 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h2><p>要找到最小的K个数，需要建立一个大顶堆，初始化一个k的元素大顶堆，对于剩下的n-k个数，遍历一下，如果遇到比堆顶元素小的，则删除堆顶元素，该元素入堆，更新堆。</p><p>时间复杂度：建堆：O(NlogK)</p><p>在python中内置的堆为小顶堆，若要找到最小的K个数，将元素取反即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr, k)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :type arr: List[int]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :type k: int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :rtype: List[int]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">0</span> <span class="keyword">or</span> k &gt; len(arr): <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>: <span class="keyword">return</span> []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">import</span> heapq</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        arr = [-a <span class="keyword">for</span> a <span class="keyword">in</span> arr]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        hp = arr[:k]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        heapq.heapify(hp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(arr)):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> arr[i] &gt; hp[<span class="number">0</span>]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                heapq.heappop(hp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                heapq.heappush(hp, arr[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> [-i <span class="keyword">for</span> i <span class="keyword">in</span> hp]</span></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>数据范围有限时直接计数排序就行了：时间复杂度O(N)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr, k)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :type arr: List[int]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :type k: int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :rtype: List[int]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        counter = [<span class="number">0</span>] * <span class="number">10000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            counter[a] += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        ans = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        idx = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(counter)):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> counter[i] &gt; <span class="number">0</span> <span class="keyword">and</span> idx &lt; k:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                ans.append(i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                idx += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                counter[i] -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> idx == k: <span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习常用算法的整理</title>
      <link href="/2021/03/31/ml/"/>
      <url>/2021/03/31/ml/</url>
      
        <content type="html"><![CDATA[<p>本文整理了常用的机器学习算法以备面试。</p><a id="more"></a><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><ul><li><p>逻辑回归的基本假设：假设数据服从<strong>伯努利分布</strong>，以p概率取1，1-p概率取0，这样的模型就是逻辑斯蒂回归模型</p></li><li><p>逻辑回归的损失函数：最大化对数似然， 使用<strong>梯度下降法</strong>来不断逼近最优解。</p></li><li><p><strong>为什么要用最大似然估计？</strong></p><ul><li>从求最优解的角度：用最小二乘的目标函数是非凸的，容易<strong>局部最优</strong>，而对数似然函数是一个凸函数，可以用梯度下降法来求解。</li><li>收敛速度：最小二乘的收敛速度慢，最大似然收敛快</li></ul><p>类似的问题：<a href="https://blog.csdn.net/saltriver/article/details/57544704" target="_blank" rel="noopener">线性回归为什么用最小二乘？</a></p><p> 最小二乘法以估计值与观测值的平方和作为损失函数，在误差服从正态分布的前提下，与极大似然估计的思想在本质上是相同。 </p></li><li><p>LR的优缺点</p><ul><li>优点：结构简单，可解释性强，训练速度快</li><li>缺点：很难拟合数据的真实分布，很难处理数据不平衡的问题，处理非线性数据比较麻烦。</li></ul></li><li><p>LR和SVM的区别：</p><ul><li><p>损失不同</p></li><li><p>LR是<strong>参数模型</strong>，SVM是非参数模型。 参数模型和非参数模型中的“参数”并不是模型中的参数，而是数据分布的参数。</p><ul><li><p>参数模型和非参数模型</p><p>​    参数机器学习模型由于指定了目标函数的形式，所以可以极大地简化这个学习的过程，但是同样会限制学习的过程。所以参数机器学习模型包括两个部分：1、选择合适的目标函数的形式。2、通过训练数据学习目标函数的参数。 </p><p> 非参数机器学习算法对目标函数形式不做过多的假设，因此算法可以通过对训练数据进行拟合而学习出某种形式的函数。 常见的非参数机器学习模型包括：决策树，朴素贝叶斯，SVM，神经网络。</p></li></ul></li></ul></li></ul><ul><li>SVM不直接依赖数据分布，而LR则依赖，因为SVM只与支持向量那几个点有关系，而LR和所有点都有关系。 </li><li>LR是经验风险最小化模型（极大似然估计），SVM是结构风险最小化模型（等价于加了正则化）</li></ul><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><p>SVM简单来说，对于线性可分的数据，最大化一个硬间隔支持向量机，近似可分时，最大化软间隔支持向量机，线性不可分时，使用<strong>核技巧</strong>学习非线性支持向量机。</p><ul><li><p>函数间隔和几何间隔</p><p>函数间隔受参数w影响，几何间隔除以L2范数，是确定的</p></li><li><p>对偶问题</p><p>对偶问题更容易求解，把目标函数和约束融为拉格朗日函数，通过这个函数来寻找最优解。</p><p>可以自然的引出核函数，进而推广到非线性分类问题</p></li><li><p>引入核函数</p><p>原本的样本空间线性不可分，通过核函数把样本映射到一个线性可分的空间去，这样以后，求解对偶问题只需知道核函数，求解难度下降。</p></li><li><p>核函数之间的区别</p><p>线性核：适用于线性可分，参数少，训练快</p><p>高斯核：适用于线性不可分，参数多，分类结果依赖于参数的好坏</p></li></ul><ul><li><p>手推SVM</p><p><img src="/2021/03/31/ml/svm.jpg" alt="avatar"></p></li></ul><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p>定义：对于给定的训练数据集，首先基于特征条件独立假设学习输入/输出的<strong>联合概率</strong>分布，然后基于该模型，对于给定的输入x，利用贝叶斯定理求出<strong>后验概率</strong>最大的输出y。</p><ul><li><p>为什么<strong>朴素</strong>？ 在计算P(X|Y)时引入了很强的特征独立，这样做可以避免求解时面临的组合爆炸和样本稀疏问题。 </p></li><li><p>优点： 对小规模的数据表现很好，适合多分类任务，适合增量式训练。收敛快。 </p></li><li>缺点： 对输入数据的表达形式很敏感（离散、连续，值极大极小之类的）。 条件独立性假设。</li></ul><h3 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h3><ul><li><p>算法原理：采用测量不同特征值间的距离或相似度的方法进行分类。如果一个样本在特征空间的K个最相似（最近邻）的样本中的大多数属于某个类别，则该样本也属于该类别。</p></li><li><p>算法决策过程：</p><ul><li>计算新数据与训练集中的特征相似度或距离</li><li>取TopK个最近邻的数据分类的标签</li><li>TopK中出现最多的作为最终的分类标签</li></ul></li><li>K的取值<ul><li>k值小：过拟合 噪声敏感</li><li>k值大：欠拟合 </li></ul></li><li>进阶：kd树</li></ul><h3 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h3><p> K-Means的一个重要的假设是：<strong>数据之间的相似度可以使用欧氏距离度量</strong>，<br>（注：<strong>可以使用欧氏距离度量</strong>的意思就是欧氏距离越小，两个数据相似度越高） </p><ul><li><p>算法步骤：</p></li><li><p><img src="/2021/03/31/ml/k-means_1.png" alt="avatar"></p></li><li><p>优点</p><ul><li>容易理解，聚类效果不错，虽然是局部最优（EM算法容易陷入局部最小值）， 但往往局部最优就够了；</li><li>处理大数据集的时候，该算法可以保证较好的伸缩性；</li><li>当簇近似高斯分布的时候，效果非常不错；</li><li>算法复杂度低。</li></ul></li><li><p>缺点</p><ul><li>K 值需要人为设定，不同 K 值得到的结果不一样；</li><li>对初始的簇中心敏感，不同选取方式会得到不同结果；</li><li>对异常值敏感；</li><li>样本只能归为一类，不适合多分类任务；</li><li>不适合太离散的分类、样本类别不平衡的分类、非凸形状的分类。</li></ul></li><li><p>改进</p><ul><li><p>数据预处理，去除异常点（数据归一化）</p></li><li><p>合理选择K值（手肘法）</p></li><li><p>基于欧式距离的 K-means 假设了了各个数据簇的数据具有一样的的先验概率并呈现球形分布，但这种分布在实际生活中并不常见。 </p><p>采用<strong>核函数</strong>， 主要思想是通过一个非线性映射，将输入空间中的数据点映射到高位的特征空间中，并在新的特征空间中进行聚类。 </p></li><li><p>二分k-means</p></li></ul></li><li><p>基础版K-means代码</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calDistance</span><span class="params">(vecA, vecB)</span>:</span>  <span class="comment"># 欧式距离</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> sum((vecA - vecB) ** <span class="number">2</span>) ** <span class="number">0.5</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initCentroids</span><span class="params">(dataSet, k)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    numSamples, dim = dataSet.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    centroids = np.zeros((k, dim))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        index = int(np.random.uniform(<span class="number">0</span>, numSamples))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        centroids[i, :] = dataSet[index, :]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> centroids</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans</span><span class="params">(dataSet, k)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    numSamples = dataSet.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># first column stores which cluster this sample belongs to,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># second column stores the error between this sample and its centroid</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    clusterAssment = np.mat(np.zeros((numSamples, <span class="number">2</span>)))  <span class="comment"># np.mat 仅仅是生成矩阵 # 相当于np.matrix</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    clusterChanged = <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">## step 1: 创建k个点作为起始质心</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    centroids = initCentroids(dataSet, k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> clusterChanged:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        clusterChanged = <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">## 对每个样本点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numSamples):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            minDist = np.inf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            minIndex = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">## step 2: 对每个质心</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">                distance = calDistance(centroids[j, :], dataSet[i, :])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> distance &lt; minDist:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">                    minDist = distance</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">                    minIndex = j</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">## step 3: 将数据点分配到距其最近的簇</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> clusterAssment[i, <span class="number">0</span>] != minIndex:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">                clusterChanged = <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">                clusterAssment[i, :] = minIndex, minDist ** <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">## step 4: 更新质心</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">            pointsInCluster = dataSet[np.nonzero(clusterAssment[:, <span class="number">0</span>] == j)[<span class="number">0</span>]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">            centroids[j, :] = np.mean(pointsInCluster, axis=<span class="number">0</span>)  <span class="comment"># 把每个簇中的所有点的均值作为新的质心</span></span></pre></td></tr></table></figure><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><ul><li><p>几个基本概念：</p><ul><li>熵：表示随机变量不确定性的度量H(X)</li><li>条件熵：已知随机变量X的条件下随机变量Y的不确定性H(Y|X)</li><li>信息增益：表示得知特征X的信息而使得类Y的信息的不确定性减少的程度g(D) = H(D)-H(D|A)</li></ul></li><li><p>决策树生成的经典算法：ID3和C4.5 分别按照信息增益和信息增益比来选择特征</p></li><li><p>决策树的剪枝</p></li><li><p>CART算法</p><p>CART是给定输入随机变量X条件下输出随机变量Y的条件概率分布的学习方法。</p><p>它假设决策树是二叉树。 CART树的生成就是递归地构建二叉决策树的过程。对回归树用平方误差最小化准则，对分类树用基尼指数最小化准则，进行特征选择，生成二叉树。 </p></li></ul><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p><a href="https://zhuanlan.zhihu.com/p/86263786" target="_blank" rel="noopener">Random Forest、Adaboost、GBDT</a></p><p>   用随机的方式建立一个森林。RF 算法由很多决策树组成，每一棵决策树之间没有关联。建立完森林后，当有新样本进入时，每棵决策树都会分别进行判断，然后基于投票法给出分类结果。 </p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>条件随机场</title>
      <link href="/2021/03/25/crf/"/>
      <url>/2021/03/25/crf/</url>
      
        <content type="html"><![CDATA[<p>条件随机场的知识点整理。</p><a id="more"></a><h3 id="判别式和生成式"><a href="#判别式和生成式" class="headerlink" title="判别式和生成式"></a>判别式和生成式</h3><ul><li><p>判别式： 直接将数据的Y（或者label），根据所提供的features，学习，最后画出了一个明显或者比较明显的边界 </p><p>判别式的模型是直接对条件概率建模（ 直接根据X特征来对Y建模训练 ）</p></li><li><p>生成式：从训练样本中学习一个联合分布P(X,Y)，然后再根据新样本x，通过条件概率计算出P(Y|X) =  P(X,Y)/P(X)</p><p>在训练阶段只对P(X,Y)建模：P(X,Y) = P(X|Y)*P(Y)</p></li></ul><h3 id="HMM-生成模型"><a href="#HMM-生成模型" class="headerlink" title="HMM 生成模型"></a>HMM 生成模型</h3><ul><li><p>几个要素：</p><ul><li>隐含状态序列 N</li><li>观测集 M</li><li>状态转移矩阵 N*N</li><li>观测概率矩阵 N*M</li><li>初始状态矩阵 N种可能</li></ul><p>属于有向图生成式模型，直接对联合概率建模</p><p>状态转移遵循1阶马尔可夫假设，1-gram （这是限制HMM性能的点）</p></li><li><p>HMM的2个假设：</p><ul><li><strong>齐次马尔可夫假设</strong>：假设隐马尔科夫链在任意时刻t的状态只依赖于前一时刻的状态</li><li><strong>观测独立性假设</strong>：任意时刻的观测只依赖于该时刻的马尔科夫链的状态</li></ul></li><li><p>学习训练过程</p><p>极大似然估计</p><p> Baum-Welch(前向后向)</p></li><li><p>解码</p><p>维特比</p></li></ul><h3 id="CRF-判别式模型"><a href="#CRF-判别式模型" class="headerlink" title="CRF 判别式模型"></a>CRF 判别式模型</h3><p>​    在序列标注中常常会用到条件随机场，一般都是线性链条件随机场。简单的来说，是只考虑概率图中<strong>相邻变量</strong>（最大团）是否满足特征函数的模型。（这里是一个马尔可夫假设）<strong>马尔科夫性是是保证或者判断概率图是否为概率无向图的条件 </strong></p><ul><li>在CRF的序列标注问题中，我们要计算的是条件概率 ，CRF做了2个假设<ul><li>指数族分布</li><li>输出之间的关联仅发生在相邻位置，并且关联是指数加性的。 </li></ul></li></ul><p>​    CRF可以在标签预测中添加一些约束，需要制定一些特征模板</p><p>​    lstm+crf，可以通过lstm学习隐层参数，不需要人工制定特征模板</p><p>​    lstm+crf学习的是：lstm的参数和crf的状态转移概率</p><ul><li><p>训练CRF</p><p>最大似然方法</p></li><li><p>解码</p><p>从m^n条路径中选出最优路径：维特比解码</p></li></ul><h3 id="CRF和HMM的不同"><a href="#CRF和HMM的不同" class="headerlink" title="CRF和HMM的不同"></a>CRF和HMM的不同</h3><ul><li><p>判别式和生成式（概率无向图和有向图模型）</p></li><li><p>CRF是对所有的特征进行全局归一化（全局最优），HMM的输出有独立性假设（局部最优）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bert中容易忽略的细节问题</title>
      <link href="/2021/03/23/bert/"/>
      <url>/2021/03/23/bert/</url>
      
        <content type="html"><![CDATA[<p>面试过程中往往遇到过一些bert中容易忽略的细节，本文做一个整理。</p><a id="more"></a><ul><li>bert中的transformer block由multi-head self-attention + FFN结构构成，但是中间还有一个<strong>” intermediate layer “</strong>，即中间层。中间层将Attention-layer的hidden size扩大了4倍，然后再做一次非线性变换(激活函数)，再将hidden size变回size。</li></ul>]]></content>
      
      
      <categories>
          
          <category> bert </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手撕排序之堆排序</title>
      <link href="/2021/03/16/sortArry/"/>
      <url>/2021/03/16/sortArry/</url>
      
        <content type="html"><![CDATA[<p>堆排序的原理是很好理解的，但是如果让你手撕堆排序，你能解决吗？</p><p>代码如下，测试通过。<a href="https://leetcode-cn.com/problems/sort-an-array/submissions/" target="_blank" rel="noopener">排序数组</a></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">heapSort</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">pass</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(self, arr, i)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""把最大元素推到堆顶"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        left, right = <span class="number">2</span> * i + <span class="number">1</span>, <span class="number">2</span> * i + <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        largest = i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> left &lt; arr_len <span class="keyword">and</span> arr[left] &gt; arr[largest]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            largest = left</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> right &lt; arr_len <span class="keyword">and</span> arr[right] &gt; arr[largest]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            largest = right</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> largest != i:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># 最大元素推到堆顶，同时向下调整继续保持为大顶堆</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            arr[largest], arr[i] = arr[i], arr[largest]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            self.heapify(arr, largest)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_max_heap</span><span class="params">(self, arr)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""建大顶堆堆, 调用 heapify()"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr) // <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            self.heapify(arr, i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(self, arr)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""堆排序"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">global</span> arr_len</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        arr_len = len(arr)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        self.build_max_heap(arr)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(arr_len - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            arr_len -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            self.heapify(arr, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> arr</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> heapSort().heap_sort(nums)</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习细节的知识点</title>
      <link href="/2021/03/08/ml-base/"/>
      <url>/2021/03/08/ml-base/</url>
      
        <content type="html"><![CDATA[<p>本文整理面试中可能出现的一些机器学习相关问题，以备记忆。</p><a id="more"></a><h3 id="BN"><a href="#BN" class="headerlink" title="BN"></a>BN</h3><p><strong>1. BN使得网络中每层输入数据的分布相对稳定，加速模型学习速度</strong></p><p>​    BN通过规范化与线性变换使得每一层网络的输入数据的均值与方差都在一定范围内，使得后一层网络不必不断去适应底层网络中输入的变化，从而实现了网络中层与层之间的解耦，允许每一层进行独立学习，有利于提高整个神经网络的学习速度。</p><p><strong>2. BN使得模型对网络中的参数不那么敏感，简化调参过程，使得网络学习更加稳定</strong></p><p><strong>3. BN允许网络使用饱和性激活函数（例如sigmoid，tanh等），缓解梯度消失问题</strong></p><p><strong>4. BN具有一定的正则化效果</strong></p><p>​    在Batch Normalization中，由于我们使用mini-batch的均值与方差作为对整体训练样本均值与方差的估计，尽管每一个batch中的数据都是从总体样本中抽样得到，但不同mini-batch的均值与方差会有所不同，这就为网络的学习过程中增加了随机噪音，与Dropout通过关闭神经元给网络训练带来噪音类似，在一定程度上对模型起到了正则化的效果。</p><p>BN 比较适用的场景是：每个 mini-batch 比较大，数据分布比较接近。在进行训练之前，要做好充分的 shuffle. 否则效果会差很多。</p><p><strong>不适用于 动态的网络结构 和 RNN 网络。</strong></p><p><a href="https://zhuanlan.zhihu.com/p/34879333" target="_blank" rel="noopener">Batch Normalization原理与实战</a></p><p><a href="https://zhuanlan.zhihu.com/p/55852062" target="_blank" rel="noopener">Batch Normalization（BN，批量归一化）</a></p><h3 id="LN"><a href="#LN" class="headerlink" title="LN"></a>LN</h3><p>针对 BN 的上述不足而提出的。它综合考虑一层所有维度的输入，计算该层的平均输入值和输入方差，然后用同一个规范化操作来转换各个维度的输入。</p><p>LN 针对单个训练样本进行，不依赖于其他数据，因此可以避免 BN 中受 mini-batch 数据分布影响的问题，可以用于 小mini-batch场景、动态网络场景和 RNN，特别是自然语言处理领域。此外，LN 不需要保存 mini-batch 的均值和方差，节省了额外的存储空间。</p><p><a href="https://zhuanlan.zhihu.com/p/33173246" target="_blank" rel="noopener">详解深度学习中的Normalization，BN/LN/WN</a></p><h3 id="L1-L2正则化"><a href="#L1-L2正则化" class="headerlink" title="L1/L2正则化"></a>L1/L2正则化</h3><ul><li>L1正则化可以产生稀疏权值矩阵，即产生一个稀疏模型，可以用于特征选择</li><li><p>L2正则化可以防止模型过拟合（overfitting）；一定程度上，L1也可以防止过拟合</p></li><li><p>L1正则化是指权值向量w w<em>w</em>中各个元素的<strong>绝对值之和</strong>，通常表示为||W1||</p></li><li>L2正则化是指权值向量w中各个元素的<strong>平方和然后再求平方根</strong></li></ul><p>L1和L2的目的是通过减少W的权重<strong>(权重衰减)</strong>从而减少模型的复杂度，从而提高模型的泛华能力。</p><p>正则化系数：通常越大的λ可以让代价函数在参数为0时取到最小值。</p><p><a href="https://blog.csdn.net/jinping_shi/article/details/52433975" target="_blank" rel="noopener">机器学习中正则化项L1和L2的直观理解</a></p><h3 id="偏差-方差"><a href="#偏差-方差" class="headerlink" title="偏差 方差"></a>偏差 方差</h3><p>偏差：描述预测和目标之间的差异</p><p>方差：数据自身的分布</p><ul><li>欠拟合 偏差大方差小</li><li>过拟合 偏差小 方差大</li></ul><p>如何解决？ 选择正确的模型，合适的模型复杂度，慎重选择数据集的大小</p><h3 id="如何理解反向传播-解释action机制"><a href="#如何理解反向传播-解释action机制" class="headerlink" title="如何理解反向传播 解释action机制"></a>如何理解反向传播 解释action机制</h3><h3 id="激活函数的意义"><a href="#激活函数的意义" class="headerlink" title="激活函数的意义"></a>激活函数的意义</h3><p>引入激活函数是为了<strong>增加神经网络模型的非线性</strong>。没有激活函数的每层都相当于矩阵相乘。即使叠加了若干层之后，无非还是个矩阵相乘。</p><p>性质：</p><p>非线性，可微性，单调性，f(x)约等于x，输出值的范围</p><ul><li>非饱和性：饱和指的是在某些区间梯度接近于零（即梯度消失），使得参数无法继续更新的问题</li></ul><p>RELU: 计算快(f(x)=max(0,x))</p><p>sigmoid,tanh</p><p>结合3者图像理解：</p><p>relu不容易梯度消失，relu的梯度大多数情况下是常数，有助于解决深层网络的收敛问题。</p><p>在LSTM中使用Relu作为激活函数：</p><p>​    RNN中共享参数W，很容易出现很大的输出值。</p><p>​    Relu不能解决梯度长距离的传递问题。</p><h3 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h3><p>梯度消失：导数小于1，随着网络成熟变多，梯度更新信息指数衰减</p><p>梯度爆炸：导数大于1，随着网络成熟变多，梯度更新信息指数增加</p><p>解决方案：</p><ol><li>梯度裁剪</li><li>relu激活函数</li><li>BN</li><li>残差结构等</li></ol><h3 id="Dropout的原理"><a href="#Dropout的原理" class="headerlink" title="Dropout的原理"></a>Dropout的原理</h3><p>神经网络在训练时，每层的迭代过程中， 随机选择中的一些神经元并将其临时隐藏(丢弃)，然后再进行本次训练和优化。 下一次迭代重复操作，以至训练结束。<strong>由于是随机丢弃，每一个mini-batch都在训练不同的网络。</strong></p><p> 在训练时，每个神经单元以概率p被保留(Dropout丢弃率为1−p)；在测试阶段，每个神经单元都是存在的，权重参数w要乘以p，输出是：pw。 </p><h3 id="神经网络相关的"><a href="#神经网络相关的" class="headerlink" title="神经网络相关的"></a>神经网络相关的</h3><h4 id="LSTM的参数如何计算"><a href="#LSTM的参数如何计算" class="headerlink" title="LSTM的参数如何计算"></a>LSTM的参数如何计算</h4><p>4个参数计算 具体见公式</p><p>sum = 4*((dim+hidden)+hidden)</p><p>GRU应该是LSTM参数的3/4</p><h4 id="有哪些优化器"><a href="#有哪些优化器" class="headerlink" title="有哪些优化器"></a>有哪些优化器</h4><ul><li>SGD 最基础的 </li><li>动量法</li><li>自适应学习率法 （减少梯度下降中的摆动）</li><li>Adam = 动量法+自适应学习率</li><li>AdamW 约等于 Adam+L2正则化 </li></ul>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微软实习内容简单梳理</title>
      <link href="/2021/03/01/microsoft-work-organization/"/>
      <url>/2021/03/01/microsoft-work-organization/</url>
      
        <content type="html"><![CDATA[<p>本文简单梳理一下微软工作中遗留的一些知识点。</p><a id="more"></a><h3 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h3><ul><li><p>简单的EDA数据增强（FGM对抗训练耗时，在embedding层添加扰动）</p><ul><li>词语替换<ul><li>基于词典的 （标准EDA）</li><li>基于词向量的（利用word2vec训练近义词）</li><li>基于TF-IDF的 （替换TF-IDF值较低的词）</li><li>基于mask LM的替换</li></ul></li><li>随机噪音注入<ul><li>随机插入</li><li>随机交换</li><li>随机删除</li></ul></li><li>回译</li></ul></li><li><p>半监督学习</p><ul><li><p>UDA无监督数据增强（<strong>个人理解的本质：在原有损失上添加针对未标注数据的正则项，使模型能够利用这些数据进行隐式迭代，最终增强泛化性能</strong>）</p><p>基于少量的有标签样本(3k)+大量的无标签样本(9w)</p><p>增强手段：回译 tf-idf替换</p><p>损失：</p><p>​    标记数据：交叉熵损失 （TSA）</p><p>​    未标记数据：<strong>通过未标记样本和增强后的样本之间的KL散度来计算loss</strong>（带温度的softmax）</p><p>训练技巧：<strong>TSA，训练信号退火，逐步去除带标签的数据避免过拟合。</strong> 采用大量的未标记数据进行训练，所需的模型会偏大，而大模型又会轻松的在有限的有监督数据上过拟合，这时TSA就要逐步的释放有监督数据的训练信号了。作者对每个training step 都设了一个阈值ηt，且小于等于1，当一个标签例子的正确类别P的概率高于阈值ηt时，模型从损失函数中删除这个例子，只训练这个minibatch下其他标记的例子。 </p></li></ul></li></ul><h3 id="知识蒸馏"><a href="#知识蒸馏" class="headerlink" title="知识蒸馏"></a>知识蒸馏</h3><p>知识蒸馏就是把大模型学习到的作为知识，蒸馏到小模型上，让小模型也具有接近大模型的精度并且提升速度。</p><p>bert作为Teacher模型，textcnn作为student模型，</p><p>损失计算部分考虑：计算textcnn与bert模型的输出的MSE-Loss，</p><p>计算textcnn与真实标签的CE-Loss</p><p>几个问题：</p><p><strong>为什么用mse-loss而不用softmax-T？</strong>因为softmax-T需要2个超参数（T和损失权重，调参难度大，不易训练，并且在实验中，mse-loss的结果更优，至于为啥用mse-loss，我理解的是mse-loss等价于计算两者之间的一个余弦相似度。）</p><p><strong>做过哪些对比试验？</strong></p><p>大模型用Roberta，AIbert，效果并不理想。小模型考虑了TextRNN，但是推理速度太慢。</p><p>数据增强：基于随机[mask]替换和n-gram采样的替换</p><h3 id="ALbert-Roberta"><a href="#ALbert-Roberta" class="headerlink" title="ALbert Roberta"></a>ALbert Roberta</h3><h4 id="Albert的改进"><a href="#Albert的改进" class="headerlink" title="Albert的改进"></a>Albert的改进</h4><ul><li>embedding因式分解，O(V*H)—&gt;O(V*E+E*H)</li><li><p>每个transformer blocks参数共享（参数不会随着模型层数加深而增大）</p></li><li><p>SOP代替NSP（预测2个句子的顺序关系）</p></li><li><p>去掉了dropout（作者认为bert一系列模型是欠拟合的）</p></li></ul><h4 id="Roberta的改进"><a href="#Roberta的改进" class="headerlink" title="Roberta的改进"></a>Roberta的改进</h4><ul><li>More data，Large batch size，Larger sequence length，Training longer</li><li>No NSP（Full sentences，每次输入连续多个句子直到512，可以跨文章）</li><li>Dynamic masking（ RoBERTa一开始把预训练的数据复制10份，每一份都随机选择15%的Tokens进行Masking，也就是说，同样的一句话有10种不同的mask方式。然后每份数据都训练N/10个epoch。这就相当于在这N个epoch的训练中，每个序列的被mask的tokens是会变化的。这就叫做动态Masking。 ）</li><li>Byte level BPE</li></ul><h4 id="补充：XLnet与bert"><a href="#补充：XLnet与bert" class="headerlink" title="补充：XLnet与bert"></a>补充：XLnet与bert</h4><p>自回归与自编码的区别</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预训练语言模型相关</title>
      <link href="/2021/03/01/PLMs/"/>
      <url>/2021/03/01/PLMs/</url>
      
        <content type="html"><![CDATA[<p>该文通过四种分类维度来划分目前已有的预训练模型。包括：</p><ul><li><p><strong>「表征的类型」</strong>,即：学习到的表征是否是上下文感知的。</p></li><li><p><strong>「编码器结构」</strong>,如：LSTM、Transformer；</p></li><li><p><strong>「预训练任务类型」</strong>,如LM，MLM，PLM；</p></li><li><p><strong>「针对特定场景的拓展」</strong>,如跨语言预训练，知识增强，多模态预训练，模型压缩等。</p><a id="more"></a></li></ul><h3 id="1-表征的类型"><a href="#1-表征的类型" class="headerlink" title="1. 表征的类型"></a>1. 表征的类型</h3><ul><li><p>非上下文感知</p><p>非上下文感知的词语表示是静态的，无法解决一词多义问题和OOV问题（Word2Vec），这种情况下一般只能通过character-level或者sub-word embedding来解决，即通过拆解词粒度为字符粒度来解决泛化性问题。</p><p>这一类的代表性工作包括：<strong>「NNLM」</strong>,<strong>「word2vec」</strong>,<strong>「GloVe」</strong>。</p></li><li><p>上下文感知</p><p>词语会随着词所在的上下文不同而动态变化，能够解决一词多义问题。token的表示需要依赖于整个文本。</p><ul><li><p>利用特征抽取器来产生上下文词嵌入表示</p><p>代表性工作：<br>(1) <strong>「CoVe」：</strong>用带注意力机制的seq2seq从机器翻译任务中预训练一个LSTM encoder。输出的上下文向量(CoVe)有助于提升一系列NLP下游任务的性能。<br>(2) <strong>「ELMo」：</strong> 用两层的Bi-LSTM从双向语言模型任务BiLM（包括1个前向的语言模型以及1个后向的语言模型）中预训练一个<strong>Bi-LSTM Encoder</strong>。能够显著提升一系列NLP下游任务的性能。</p></li><li><p>微调</p><p>代表性工作：</p><p>(1) <strong>「ULMFiT」：</strong> 通过在文本分类任务上微调预训练好的语言模型达到了state-of-the-art结果。这篇也预训练模型微调模式的开创性工作。提出了3个阶段的微调：在通用数据上进行语言模型的预训练来学习通用语言特征；在目标任务所处的领域特定的数据上进行语言模型的微调来学习领域特征；在目标任务上进行微调。<br>(2) <strong>「GPT」：</strong>使用单向的Transformer预训练单向语言模型。单向的Transformer里头用到了masked self-attention的技巧（相当于是Transformer原始论文里头的Decoder结构），即当前词只能attend到前面出现的词上面。之所以只能用单向transformer，主要受制于单向的预训练语言模型任务，否则会造成信息泄露。</p><p>(3) <strong>「BERT」：</strong>使用双向Transformer作为Encoder（即Transformer中的Encoder结构)，引入了新的预训练任务，带mask的语言模型任务MLM和下一个句子预测任务NSP。由于MLM预训练任务的存在，使得Transformer能够进行<strong>「双向」</strong>self-attention。</p></li></ul></li></ul><h3 id="2-上下文编码器架构"><a href="#2-上下文编码器架构" class="headerlink" title="2. 上下文编码器架构"></a>2. 上下文编码器架构</h3><ul><li><p>卷积（TextCNN）</p></li><li><p>序列（Bi-LSTM）</p></li><li><p>图模型</p><p>Transformer也是一种图网络的特例：句子中的词构成一张全连接图，图中任意两个词之间都有连边，连边的权重衡量了词之间的关联，通过self-attention来动态计算，目标是让模型自动学习到图的结构（实际上，图上的结点还带了词本身的属性信息，如位置信息等）</p></li></ul><h3 id="3-预训练任务"><a href="#3-预训练任务" class="headerlink" title="3. 预训练任务"></a>3. 预训练任务</h3><p>监督学习，无监督学习，自监督学习</p><p>自监督学习：核心思想是，用输入数据的一部分信息以某种形式去预测其另一部分信息。例如BERT中使用的MLM，输入数据是句子，通过句子中其它部分的单词信息来预测一部分masked的单词信息。-</p><ul><li><p>语言模型（LM）</p><p>语言模型是指一类能够求解句子概率的概率模型，通常通过概率论中的链式法则来表示整个句子各个单词间的联合概率。链式求导法则的关键特点和原理是<strong>当前词的表示依赖于前面的单词（单向的自回归的）</strong>。</p></li><li><p>带掩码的语言模型（MLM）</p><p>MLM主要是从BERT开始流行起来的，能够解决单向的LM的问题，进行双向的信息编码。</p><p>MLM存在的缺点：</p><ul><li>会造成pre-training和fine-tuning之间的gap。[MASK]特殊字符不会出现在fine-tuning阶段出现</li><li>MLM收敛的速度比较慢</li><li>MLM不是标准的语言模型，其有着自己的独立性假设，即假设mask词之间是相互独立的。</li><li>自回归LM模型能够通过联合概率的链式法则来计算句子的联合概率，而MLM只能进行<strong>「联合概率的有偏估计」</strong>(mask之间没有相互独立)</li></ul><p>增强版MLM：</p><ul><li><strong>RoBERTa：</strong>改进了BERT种静态masking的方法，采用了动态masking的方法。</li><li><strong>UniLM：</strong>拓展mask prediction任务到三种语言模型任务中，单向预测、双向预测、seq2seq预测。</li><li><strong>XLM：</strong>将MLM应用到翻译语言模型中，即“双语料句子对“构成一个句子，然后使用MLM。</li><li><strong>SpanBERT：</strong>使用了span masking来随机掩盖一段连续的词。同时额外提出了一种<strong>边界学习目标</strong> ，希望被掩盖的词能够融入边界的信息，即基于边界之外的两个单词的向量和masked单词的位置向量来预测masked单词。</li><li><strong>ERNIE：</strong>将外部知识融入到MLM中。引入了命名实体外部知识来掩盖实体单元，进行训练。</li></ul></li><li><p>排列语言模型（PLM）</p><p>PLM在<strong>XLNet</strong>中被提出。动机来源：预训练和微调阶段的gap，mask词之间的独立性假设等。</p><p>在传统的单向自回归语言模型LM中，句子的联合概率因子分解是按照从左到右或者从右到左的方式分解成条件概率的链式乘积的，这可以看作是其中两种联合概率的因子分解序。实际上，句子的联合概率的因子分解序还可以有很多种，可以任意的排列组合进行因子分解。PLM就是对联合概率进行因子分解得到排列，分解得到的排列只决定了模型自回归时的预测顺序，不会改变原始文本序列的自然位置。即：PLM只是针对语言模型建模不同排列下的因子分解排列，并不是词的位置信息的重新排列。</p><ul><li><p>XLNet</p><p>XLNet在输入阶段并没有改变输入顺序，随机打乱输入句子的顺序这个过程是在Transformer中通过<strong>Attention mask</strong>实现的，就是随机掩盖掉序列中的一些单词，并将未掩盖掉的单词作为预测单词的上文。</p></li></ul></li></ul><h3 id="自回归与自编码模型"><a href="#自回归与自编码模型" class="headerlink" title="自回归与自编码模型"></a>自回归与自编码模型</h3><ul><li><p>自回归（GPT, XLNet, EMLo）</p><p>根据上文内容预测下一个单词，或者根据下文预测前面的单词，这种类型的LM被称为自回归语言模型。</p><p>自回归语言模型有优点有缺点，优点是自然地引入上下文信息，并且解决<strong>自编码语言模型</strong>两阶段保持一致的问题。缺点是只能利用上文或者下文的信息，不能同时利用上文和下文的信息（ELMo融合方式过于简单所以效果不好）。</p></li><li><p>自编码（BERT）</p></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://zhuanlan.zhihu.com/p/317260710" target="_blank" rel="noopener">2020最新NLP预训练模型综述</a></p><p><a href="https://zhuanlan.zhihu.com/p/70257427" target="_blank" rel="noopener">XLNet:运行机制及和Bert的异同比较</a><a href="https://zhuanlan.zhihu.com/p/70257427" target="_blank" rel="noopener">XLNet:运行机制及和Bert的异同比较</a></p>]]></content>
      
      
      <categories>
          
          <category> LM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> deeplearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>knowledge distillation</title>
      <link href="/2021/01/20/knowledge-distillation/"/>
      <url>/2021/01/20/knowledge-distillation/</url>
      
        <content type="html"><![CDATA[<p>训练和部署两个阶段对模型的要求是不同的。在训练阶段，我们希望模型可以从大量的、高度冗余的信息中学到数据的特征，此阶段对延迟和计算资源没有太严格的要求。但是如果模型要被部署到大量用户那里，对延迟和计算资源的限制就很高。因此，我们可以先训练一个大模型。这个大模型可以是很多独立模型的集成，也可以是单个的使用了Dropout等正则化方法的复杂模型。在大模型训练好之后，我们就可以使用一个称为<strong>“蒸馏”</strong>的训练过程，将大模型中的知识迁移到便于部署的小模型中。</p><a id="more"></a><p> 知识蒸馏，可以将一个网络的知识转移到另一个网络，两个网络可以是同构或者异构。做法是先训练一个teacher网络，然后使用这个teacher网络的输出和数据的真实标签去训练student网络。知识蒸馏，可以用来将网络从大网络转化成一个小网络，并保留接近于大网络的性能；也可以将多个网络的学到的知识转移到一个网络中，使得单个网络的性能接近emsemble的结果。  知识蒸馏的本质，个人理解，<strong>其实知识蒸馏实际相当于引入先验概率（prior knowledge)</strong>， soft label即是网络输入的先验概率，soft label与真实世界的事物类似，呈各种概率分布。 </p><p>  我们通过小的模型去学习大的模型的直接输出，往往能够得到更好的结果，这是因为大的模型的信息熵比onehot的结果往往更多，小的模型能获得的信息量更大。 <strong>使用知识蒸馏得到的小模型，其泛化能力会比使用一般方法训练得到的小模型要好。</strong> </p><h3 id="基于bert的知识蒸馏"><a href="#基于bert的知识蒸馏" class="headerlink" title="基于bert的知识蒸馏"></a>基于bert的知识蒸馏</h3><ul><li><p><strong>DistillBert</strong></p><ul><li><p>teacher model: bert</p></li><li><p>student model改动：</p><ul><li><p>每2层去掉1层（作者调研后结果是隐藏层维度的变化比层数的变化对计算性能的影响较小，所以只改变了层数，把计算层数减小到原来的一半）</p></li><li><p>去掉了token type embedding和pooler</p></li></ul></li><li><p>每一层加了初始化，每一层的初始化为teacher model的参数。 </p></li><li><p>在训练过程中使用了<strong>动态掩码</strong>（dynamic masking）然后没有使用next sentence objective。训练数据和原始的Bert训练使用的一样。 </p></li><li><p>loss设计：</p><ul><li>Lce loss:  Teacher model的soft label的损失函数， Teacher model的logits ti/T(T 为温度),通过softmax计算输出得到teacher的概率分布，与student model logits si/T(T为温度)，通过softmax计算输出得到student的概率分布，最后计算两个概率分布的KL散度 </li><li><p>Lmlm loss: Bert的Mask language modeling loss( 单词级别分类任务 )</p></li><li><p>Lcos loss:  计算teacher hidden state和student hidden state的余弦相似度。官方代码用的是：nn.CosineEmbeddingLoss</p><p>整体的loss：Loss = 5.0*Lce + 2.0*Lmlm + 1.0*Lcos</p></li></ul></li></ul></li></ul><ul><li><p><strong>Bert-PKD</strong></p><p>普通的知识蒸馏模型用来对模型进行压缩的时候, 通常都会损失很多精度。原因是学生模型 (student model) 在学习的时候只是学到了教师模型 (teacher model) 最终预测的概率分布，而完全忽略了中间隐藏层的表示。  该方法提出了一种损失函数，使得学生模型的隐藏层表示接近教师模型的隐藏层表示，从而让学生模型的泛化能力更强。文章称这种模型为“耐心的知识蒸馏”模型 (Patient Knowledge Distillation， 或者PKD)。 </p><ul><li><p>teacher model：bert</p></li><li><p>student model改动：</p><ul><li><strong>蒸馏模型的中间层：</strong> PKD-last(7,8,9,10,11)  PKD-skip(2,4,6,8,10)</li><li><strong>student初始化：</strong>teacher的前几层</li></ul></li><li><p>loss设计</p><ul><li>中间层损失L_PT (MSE)</li><li>真实标签损失L_CE (CE)</li><li>student和teacher之间的损失L_DS (temperature softmax)</li></ul><p>LOSS = (1-a)*L_CE + a*L_DS + L_PT</p></li></ul></li><li><p><strong>TinyBert</strong></p><p>一般的蒸馏只是蒸馏bert的最后一层的结果，而很少关注transformer中间层的信息</p><ul><li><p>loss设计</p><ul><li><p><strong>Embedding-layer </strong></p><p>student和teacher的embedding之间计算MSE</p></li><li><p><strong>Transformer-layer </strong> <strong>采用隔 k 层蒸馏的方式 </strong></p><p>若设置student BERT的层数为4，则teacher的第3、6、9、12分别对应student的1、2、3、4层</p><p>每一层的transformer的loss又包含2个部分：</p><ul><li><p><strong>attention based distillation</strong></p><p>对attention score矩阵(n*n)计算MSE</p><p>（attention可以学到句子的语法相关信息，并且[CLS],[SEP]等token有很高的权重）</p></li><li><p><strong>hidden states based distillation</strong></p><p>student和teacher的transformer的隐层输出计算MSE</p></li></ul></li><li><p><strong>Prediction-Layer </strong></p><p>​        student和teacher输出概率分布的交叉熵</p></li></ul></li><li><p>实验细节   <strong>两阶段学习框架 </strong></p><p>TinyBERT 先在 general domain 数据集上用未经微调的 BERT 充当教师蒸馏出一个 base 模型，在此基础上，具体任务通过数据增强，利用微调后的 BERT 再进行重新执行蒸馏。</p><p>蒸馏 TinyBERT 的流程是:</p><ol><li>制作任务相关数据集;</li><li>fine-tune teacher BERT;</li><li>固定 teacher BERT 参数，蒸馏得到 TinyBERT.</li></ol></li></ul></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://arxiv.org/abs/1910.01108" target="_blank" rel="noopener">DistilBERT, a distilled version of BERT: smaller, faster, cheaper and lighter</a></p><p><a href="https://arxiv.org/abs/1908.09355" target="_blank" rel="noopener">Patient Knowledge Distillation for BERT Model Compression </a></p><p><a href="https://arxiv.org/abs/1909.10351" target="_blank" rel="noopener">TinyBERT: Distilling BERT for Natural Language Understanding</a></p><p><a href="https://zhuanlan.zhihu.com/p/94359189" target="_blank" rel="noopener">比 Bert 体积更小速度更快的 TinyBERT</a></p>]]></content>
      
      
      <categories>
          
          <category> Distillation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> distillation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformer</title>
      <link href="/2021/01/20/Transformer/"/>
      <url>/2021/01/20/Transformer/</url>
      
        <content type="html"><![CDATA[<p>本文以QA的方式整理关于transformer的知识点。</p><a id="more"></a><h3 id="1-Transformer的结构是什么样的？"><a href="#1-Transformer的结构是什么样的？" class="headerlink" title="1.Transformer的结构是什么样的？"></a>1.Transformer的结构是什么样的？</h3><p>transformer本质上还是一个典型的encoder-decoder模型，encoder和decoder端各有6个相同的大模块构成。</p><ul><li>encoder（由2个子模块构成）：多头self-attention+前馈神经网络</li><li>decoder（由3个子模块构成）：多头self-attention+多头Encoder-Dencoder attention交互模块+前馈神经网络</li></ul><h3 id="2-Transformer-Encoder和Decoder-端的输入输出具体是什么？"><a href="#2-Transformer-Encoder和Decoder-端的输入输出具体是什么？" class="headerlink" title="2. Transformer Encoder和Decoder 端的输入输出具体是什么？"></a>2. Transformer Encoder和Decoder 端的输入输出具体是什么？</h3><p>Encoder端：</p><ul><li>输入：Encoder 端每个大模块接收的输入是不一样的，第一个大模块(最底下的那个)接收的输入是输入序列的 embedding(embedding 可以通过 word2vec 预训练得来)，其余大模块接收的是其前一个大模块的输出。</li><li>输出：最后一个模块的输出作为整个 Encoder 端的输出。</li></ul><p>Decoder端：</p><ul><li>输入：encoder的输出 &amp; 对应i-1位置decoder的输出。所以中间的attention不是self-attention，它的K，V来自encoder，Q来自上一位置decoder的输出</li><li>输出：对应i位置的输出词的概率分布</li><li>解码：<strong>编码可以并行计算，一次性全部encoding出来，但解码不是一次把所有序列解出来的，而是像rnn一样一个一个解出来的</strong>，因为要用上一个位置的输入当作attention的query。</li></ul><h3 id="3-Transformer-中的-self-attention-是什么？self-attention-的计算过程？"><a href="#3-Transformer-中的-self-attention-是什么？self-attention-的计算过程？" class="headerlink" title="3. Transformer 中的 self-attention 是什么？self-attention 的计算过程？"></a>3. Transformer 中的 self-attention 是什么？self-attention 的计算过程？</h3><ul><li><p>self-attention是什么？</p><p>self-attention是一种通过自身和自身相关联的 attention 机制（而attention本身就是一种特征加权求和的计算）。在 self-attention 中， 序列中的每个单词和该序列中其余单词进行 attention 计算。self-attention 的特点在于<strong>无视token之间的距离直接计算依赖关系，从而能够学习到序列的内部结构</strong>，实现起来也比较简单。引入 Self Attention 后会<strong>更容易捕获句子中长距离的相互依赖的特征</strong>，因为如果是 RNN 或者 LSTM，需要依次序序列计算，对于远距离的相互依赖的特征，要经过若干时间步步骤的信息累积才能将两者联系起来，而距离越远，有效捕获的可能性越小。 Self-Attention 在计算过程中会直接将句子中任意两个单词的联系通过一个计算步骤直接联系起来，所以远距离依赖特征之间的距离被极大缩短，有利于有效地利用这些特征。除此外，Self Attention 对于<strong>增加计算的并行性</strong>也有直接帮助作用。</p></li><li><p>self-attention的计算过程</p><script type="math/tex; mode=display">Attention(Q,K,V)=softmax(\frac{QK^{T}}{\sqrt{d_{k}}})V</script></li><li><p><strong>为什么要有一个根号d_k？</strong> 假设两个 dk 维向量每个分量都是一个相互独立的服从标准正态分布的随机变量，那么他们的点乘结果会变得很大，并且服从均值为0，方差就是 dk，【很大的点乘会让softmax函数处在梯度很小的区域】，对每一个分量除以 sqrt(d_k) 可以让点乘的方差变成 1。 </p></li></ul><h3 id="4-如何理解self-attention中的Q-K-V"><a href="#4-如何理解self-attention中的Q-K-V" class="headerlink" title="4.如何理解self-attention中的Q,K,V?"></a>4.如何理解self-attention中的Q,K,V?</h3><p>​    <strong>计算attention的过程，即使用一个Q(query)，计算它和每个K(key)的相似度作为权重，对所有的V(value)进行加权求和。</strong></p><p>​    QKV来源于input的embedding，通过神经网络学习到不同的权重。简单来理解：Q是当前词，K是其他词，V是内容。</p><h3 id="5-Transformer-为什么需要进行-Multi-head-Attention？这样做有什么好处？Multi-head-Attention-的计算过程？"><a href="#5-Transformer-为什么需要进行-Multi-head-Attention？这样做有什么好处？Multi-head-Attention-的计算过程？" class="headerlink" title="5. Transformer 为什么需要进行 Multi-head Attention？这样做有什么好处？Multi-head Attention 的计算过程？"></a>5. Transformer 为什么需要进行 Multi-head Attention？这样做有什么好处？Multi-head Attention 的计算过程？</h3><p>将模型分为多个头，形成多个子空间，可以让模型去关注不同方面的信息，最后再将各个方面的信息综合起来。类比 CNN 中同时使用多个卷积核的作用，多头的注意力有助于网络捕捉到更丰富的特征/信息。</p><h3 id="6-Transformer-是如何训练的？测试阶段如何进行测试呢？"><a href="#6-Transformer-是如何训练的？测试阶段如何进行测试呢？" class="headerlink" title="6. Transformer 是如何训练的？测试阶段如何进行测试呢？"></a>6. Transformer 是如何训练的？测试阶段如何进行测试呢？</h3><p>Transformer 训练过程与 seq2seq 类似，首先 Encoder 端得到输入的 encoding 表示，并将其输入到 Decoder 端做交互式 attention，之后在 Decoder 端接收其相应的输入，经过多头 self-attention 模块之后，结合 Encoder 端的输出，再经过 FFN，得到 Decoder 端的输出之后，最后经过一个线性全连接层，就可以通过 softmax 来预测下一个token，然后根据 softmax 多分类的损失函数，将 loss 反向传播即可，所以从整体上来说，Transformer 训练过程就相当于一个有监督的多分类问题。</p><p>而对于测试阶段，其与训练阶段唯一不同的是 Decoder 端最底层的输入，先生成第一个位置的输出，然后有了这个之后，第二次预测时，再将其加入输入序列，以此类推直至预测结束。</p><ul><li>需要注意的是，Encoder 端可以并行计算，一次性将输入序列全部 encoding 出来，但 Decoder 端不是一次性把所有token预测出来的，而是像 seq2seq 一样一个接着一个预测出来的。</li></ul><h3 id="7-Transformer的并行化体现在哪里？"><a href="#7-Transformer的并行化体现在哪里？" class="headerlink" title="7. Transformer的并行化体现在哪里？"></a>7. Transformer的并行化体现在哪里？</h3><p>Transformer 的并行化主要体现在 self-attention 模块，在 Encoder 端 Transformer 可以并行处理整个序列，并得到整个输入序列经过 Encoder 端的输出，在 self-attention 模块，对于某个序列x1,x2,…,xn ，self-attention 模块可以直接计算xi*xj的点乘结果，而 RNN 系列的模型就必须按照顺序从x1计算到xn。</p><h3 id="8-Transformer的位置编码？"><a href="#8-Transformer的位置编码？" class="headerlink" title="8. Transformer的位置编码？"></a>8. Transformer的位置编码？</h3><p>为什么要引入位置编码？ 如果没有位置编码，就失去了词序的信息。</p><p> 给定一个长度为n的输入序列，让t表示词在序列中的位置，p_t表示t位置对应的向量，d是向量的维度。f是生成位置向量p_t的函数，定义如下： </p><script type="math/tex; mode=display">\vec{p_t}^{(i)} = f(t)^{(i)} := \begin{cases}      \sin({\omega_k} . t),  & \text{if}\  i = 2k \\      \cos({\omega_k} . t),  & \text{if}\  i = 2k + 1  \end{cases}</script><script type="math/tex; mode=display">where\quad \omega_k = \frac{1}{10000^{2k / d}}</script><ul><li>它能为每个时间步输出一个独一无二的编码；</li><li>不同长度的句子之间，任何两个时间步之间的距离应该保持一致；</li><li>模型应该能毫不费力地泛化到更长的句子。它的值应该是有界的；</li><li>它必须是确定性的。</li><li>正弦曲线函数的位置编码的另一个特点是，它能让模型毫不费力地关注相对位置信息 ， 因为对于任何固定的偏移量<img src="https://www.zhihu.com/equation?tex=k" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=%5Ctext%7BPE%7D_%7B%5Ctext%7Bpos%7D%2Bk%7D" alt="[公式]">可以表示成<img src="https://www.zhihu.com/equation?tex=%5Ctext%7BPE%7D_%7B%5Ctext%7Bpos%7D%7D" alt="[公式]">的线性函数。 </li></ul><h3 id="9-Transformer的时间复杂度是多少？对比RNN，CNN呢？"><a href="#9-Transformer的时间复杂度是多少？对比RNN，CNN呢？" class="headerlink" title="9. Transformer的时间复杂度是多少？对比RNN，CNN呢？"></a>9. Transformer的时间复杂度是多少？对比RNN，CNN呢？</h3><p><em>一个形状为N\</em>M的矩阵，与另一个形状为M*P的矩阵相乘，其运算复杂度来源于乘法操作的次数，时间复杂度为 O(N<em>M</em>P)。*</p><ul><li><p>self-attention</p><ul><li>Q,K,V：n*d</li><li>相似度计算：Q*K^T，复杂度为O(n^2d)</li><li>softmax计算：对每行做softmax，复杂度为 O(n)，则n行的复杂度为 O(n^2)</li><li>加权和：n*n与n*d运算，得到n*d矩阵，复杂度为O(n^2d)</li></ul><p>所以self-attention的时间复杂度为O(n^2d)</p></li><li><p>Multi-Head Attention</p><script type="math/tex; mode=display">MultiHead(Q,K,V) = Concat(head_1,...,head_h)W^O</script><script type="math/tex; mode=display">Where \quad head_i = Attention(QW_{i}^Q,KW_{i}^k,VW_i^V)</script><p>假设有h个head（h为常数），对于每个head，对于每个head，首先需要把三个矩阵分别映射到 d_q,d_k,d_v 维度。d_q=d_k=d_v=d/h。</p><ul><li>输入线性映射的复杂度：n*d与d*d/h运算，复杂度为O(nd^2)</li><li>Attention的计算：O(n^2d)</li><li>输出线性映射的复杂度：concat操作拼起来形成 n*d 的矩阵，然后经过输出线性映射，保证输入输出相同，所以是n*d 与 d*d 计算，复杂度为O(nd^2)</li></ul><p>所以Multi-Head Attention的时间复杂度为O(nd^2+n^2d)</p><p>注：多头的计算并不是通过循环完成的，而是通过 transposes and reshapes，用矩阵乘法来完成的。假设有h个head，则新的representation dimension：m=d/h。因为，我们将n*d矩阵拆为n*h*m张量，再利用转置操作转为h*n*m 的张量。故 QK^T的计算为： h*n*m与 h*m*n做计算，得到h*n*n的张量，复杂度为O(h^2n^2m)，即O(n^2dh) 。注意，此处h实际是一个常数，故QK^T复杂度为O(n^2d) 。</p></li></ul><h3 id="10-Transformer为什么要引入LN？"><a href="#10-Transformer为什么要引入LN？" class="headerlink" title="10. Transformer为什么要引入LN？"></a>10. Transformer为什么要引入LN？</h3><ul><li><p>LN则是针对每一句话做归一化处理。例如：我是中国人我爱中国——归一化处理后，一句话内每个字之间的联系并没有破坏。 </p></li><li><p>layer normalization 有助于得到一个球体空间中符合<strong>0均值1方差</strong>高斯分布的 embedding， batch normalization不具备这个功能。 </p></li><li>layer normalization可以对transformer学习过程中由于多词条embedding累加可能带来的“尺度”问题施加约束，相当于对表达每个词<strong>一词多义的空间施加了约束</strong>，有效降低模型方差。batch normalization也不具备这个功能。</li></ul><h3 id="Renference"><a href="#Renference" class="headerlink" title="Renference"></a>Renference</h3><p><a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention Is All You Need</a></p><p><a href="https://blog.csdn.net/fengdu78/article/details/104629336" target="_blank" rel="noopener">关于Transformer，面试官们都怎么问？</a></p><p><a href="http://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">The Illustrated Transformer</a></p><p><a href="https://zhuanlan.zhihu.com/p/264749298" target="_blank" rel="noopener">Transformer/CNN/RNN的对比（时间复杂度，序列操作数，最大路径长度）</a></p><p><a href="https://zhuanlan.zhihu.com/p/54356280" target="_blank" rel="noopener">BERT大火却不懂Transformer？读这一篇就够了</a></p><p><a href="https://kazemnejad.com/blog/transformer_architecture_positional_encoding/" target="_blank" rel="noopener">Transformer Architecture: The Positional Encoding</a></p><p><a href="https://www.zhihu.com/question/395811291" target="_blank" rel="noopener">Transformer 为什么使用 layer normalization，而不是其他的归一化</a></p><p><a href="https://zhuanlan.zhihu.com/p/106644634" target="_blank" rel="noopener">Transformer中的位置编码</a></p>]]></content>
      
      
      <categories>
          
          <category> deeplearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> deeplearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RNN相关知识点</title>
      <link href="/2021/01/18/RNN/"/>
      <url>/2021/01/18/RNN/</url>
      
        <content type="html"><![CDATA[<p>引入RNN：处理序列问题</p><a id="more"></a><p>最基本的单层网络结构为，输入x，经过Wx+b和激活函数得到输出y。RNN在这个基础上引入了隐藏层h，h可对序列数据提取特征，接着在转换为输出。</p><p>隐层计算为</p><script type="math/tex; mode=display">h_n = f(Ux_1+Wh_{n-1}+b)</script><p>每个步骤<strong>权值共享</strong>，使用的参数U , W , b相同，激活函数为tanh。</p><p>RNN存在的问题：<strong>梯度消失</strong>。由于结构上的限制，很长的时刻以前的输入，对现在的网络影响非常小，后向传播时那些梯度，也很难影响很早以前的输入，即会出现梯度消失的问题。（<strong>梯度被近距离梯度主导，导致模型难以学到远距离的依赖关系</strong>）</p><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><p>LSTM的结构：每个循环的模块内有4层结构: 3个sigmoid层，1个tanh层</p><p>遗忘门：决定丢弃信息</p><script type="math/tex; mode=display">f_t = \sigma(W_f\cdot[h_{t-1},x_t]+b_f)</script><p>输入门：决定更新哪些值</p><script type="math/tex; mode=display">i_t=\sigma(W_i\cdot[h_{t-1},x_t]+b_i)</script><script type="math/tex; mode=display">\widetilde{C}_t=tanh(W_C\cdot[h_{t-1},x_t]+b_C)</script><script type="math/tex; mode=display">C_t=f_t*C_{t-1}+i_t*\widetilde{C}_t</script><p>输出门：决定最终输出的值</p><script type="math/tex; mode=display">o_t = \sigma(W_o\cdot[h_{t-1},x_t]+b_o)</script><script type="math/tex; mode=display">h_t = o_t*tanh(C_t)</script><ul><li><p>LSTM如何解决梯度消失和爆炸问题</p><p><a href="https://www.zhihu.com/question/34878706/answer/665429718" target="_blank" rel="noopener">LSTM如何来避免梯度弥散和梯度爆炸？</a></p><p>梯度消失的本质：由于时间维度共享了参数矩阵，导致计算隐态h时会循环计算矩阵乘法，所以随时间反向传播算法求解梯度时出现了参数矩阵的累乘。</p><p>LSTM解决问题的本质：引入gate机制，把矩阵乘法变成了逐位相乘，记忆状态的更新公式为ct。</p></li></ul><h3 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h3><p>更新门+输出门</p><script type="math/tex; mode=display">z_t=\sigma(W_z\cdot[h_{t-1},x_t])</script><script type="math/tex; mode=display">r_t=\sigma(W_r\cdot[h_{t-1},x_t])</script><script type="math/tex; mode=display">\widetilde{h}_t = tanh(S\cdot[r_t*h_{t-1},x_t])</script><script type="math/tex; mode=display">h_t = (1-z_t)*h_{t-1}+z_t*\widetilde{h}_t</script><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.jianshu.com/p/9dc9f41f0b29/" target="_blank" rel="noopener">理解LSTM</a></p><p><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a></p>]]></content>
      
      
      <categories>
          
          <category> deeplearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> deeplearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode中位运算的整理</title>
      <link href="/2020/10/15/Bit-manipulation/"/>
      <url>/2020/10/15/Bit-manipulation/</url>
      
        <content type="html"><![CDATA[<p>位运算中常常有一些很骚的思路，本文整理了算法题中常见的位运算的细节。</p><a id="more"></a><h2 id="1-不用中间变量交换2个数的值"><a href="#1-不用中间变量交换2个数的值" class="headerlink" title="1.不用中间变量交换2个数的值"></a>1.不用中间变量交换2个数的值</h2><p>a = a^b</p><p>b = a^b</p><p>a = a^b</p><p>解释：<strong>b = a^a^b, a = a^b^b</strong></p><p>同样原理适用于题目：找出数组中不重复的元素，其他元素均出现2次</p><h2 id="2-计算数字的二进制中有多少个1"><a href="#2-计算数字的二进制中有多少个1" class="headerlink" title="2.计算数字的二进制中有多少个1"></a>2.计算数字的二进制中有多少个1</h2><p>法1：常规解法：循环右移。，每次判断最后1位是不是1   <strong>(n&amp;1)==1 </strong></p><p>法2：<strong>n&amp;(n-1)</strong> 每次去掉二进制从前往后的最后1个1</p><h2 id="3-每次改变一个数中二进制的一位"><a href="#3-每次改变一个数中二进制的一位" class="headerlink" title="3.每次改变一个数中二进制的一位"></a>3.每次改变一个数中二进制的一位</h2><p><strong>n^(1&lt;&lt;i)</strong> ：表示改变n的第i位</p><h2 id="4-找出数组中消失的2个数字"><a href="#4-找出数组中消失的2个数字" class="headerlink" title="4. 找出数组中消失的2个数字"></a>4. 找出数组中消失的2个数字</h2>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题整理</title>
      <link href="/2020/09/18/bag/"/>
      <url>/2020/09/18/bag/</url>
      
        <content type="html"><![CDATA[<p>整理了一下几种背包问题。</p><a id="more"></a><h2 id="背包问题I"><a href="#背包问题I" class="headerlink" title="背包问题I"></a>背包问题I</h2><p><strong>描述：</strong>在<code>n</code>个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为<code>m</code>，每个物品的大小为<code>A[i]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">backpack_1</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack_1</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (A.length == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length + <span class="number">1</span>][m + <span class="number">1</span>]; <span class="comment">//表示 当前选择第i个物品背包容量为j的情况</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.length; i++) &#123; <span class="comment">//遍历物品</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (j &gt;= A[i - <span class="number">1</span>]) &#123; <span class="comment">//2种情况： 当前物品选和不选</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                                        dp[i - <span class="number">1</span>][j - A[i - <span class="number">1</span>]] + A[i - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[A.length][m];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//二维变一维</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack_2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (A.length == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j--) &#123; <span class="comment">//这边需要倒序 因为dp[i-1][j-A[i-1]]不会被提前更新</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (j &gt;= A[i - <span class="number">1</span>]) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                    dp[j] = Math.max(dp[j], dp[j - A[i - <span class="number">1</span>]] + A[i - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[m];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="背包问题II（01背包）"><a href="#背包问题II（01背包）" class="headerlink" title="背包问题II（01背包）"></a>背包问题II（01背包）</h2><p><strong>描述：</strong>有 <code>n</code> 个物品和一个大小为 <code>m</code> 的背包. 给定数组 <code>A</code> 表示每个物品的大小和数组 <code>V</code> 表示每个物品的价值.</p><p>问最多能装入背包的总价值是多大?（每个物品只能取一次）  </p><p>思路和上题一样，只需要修改一处即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">backpack_2</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackII_1</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || A.length == <span class="number">0</span> || V.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length + <span class="number">1</span>][m + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (j &gt;= A[i - <span class="number">1</span>]) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                                        dp[i - <span class="number">1</span>][j - A[i - <span class="number">1</span>]] + V[i - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[A.length][m];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackII_2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || A.length == <span class="number">0</span> || V.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (j &gt;= A[i - <span class="number">1</span>]) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                    dp[j] = Math.max(dp[j], dp[j - A[i - <span class="number">1</span>]] + V[i - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[m];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="背包问题III（完全背包-求值）"><a href="#背包问题III（完全背包-求值）" class="headerlink" title="背包问题III（完全背包 求值）"></a>背包问题III（完全背包 求值）</h2><p><strong>描述：</strong>给定<code>n</code>种大小为<code>A[i]</code>，值为<code>V[i]</code>的物品(每个物品都有无限多的可用物品)和一个大小为<code>m</code>的背包，你能放入背包的最大值是多少?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">backpack_3</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//思路：视为特殊的多重背包问题 每个物品的个数的最大为m/A[i]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII_1</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || A.length == <span class="number">0</span> || V.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length + <span class="number">1</span>][m + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = A[i - <span class="number">1</span>]; j &lt;= m; j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">//第i个不选</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * A[i - <span class="number">1</span>] &lt;= m; k++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (j &gt;= k * A[i - <span class="number">1</span>]) &#123; <span class="comment">//当前第i个情况不选(k=0) 或者选k个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                        dp[i][j] = Math.max(dp[i][j],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                                dp[i - <span class="number">1</span>][j - k * A[i - <span class="number">1</span>]] + k * V[i - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[A.length][m];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//多重背包问题解完全背包问题的DP优化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII_2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || A.length == <span class="number">0</span> || V.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * A[i - <span class="number">1</span>] &lt;= m; k++) &#123;  <span class="comment">//遍历当前该元素的个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= A[i - <span class="number">1</span>]; j--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">//当前元素 不取 或者取1个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                    dp[j] = Math.max(dp[j], dp[j - A[i - <span class="number">1</span>]] + V[i - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[m];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//另一种思路 同leetcode518 零钱兑换II</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII_3</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || A.length == <span class="number">0</span> || V.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = A[i - <span class="number">1</span>]; j &lt;= m; j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">//对于当前物品i，若j从小到大的话，很可能在j之前的j-A[i-1]时已经放过第i件物品了，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 在j时再放就是重复放入；若j从大到小，则j之前的所有情况都没有更新过，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 不可能放过第i件物品，所以不会重复放入。 //与第二题相反</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">                dp[j] = Math.max(dp[j], dp[j - A[i - <span class="number">1</span>]] + V[i - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[m];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="背包问题IV（完全背包-求方案）"><a href="#背包问题IV（完全背包-求方案）" class="headerlink" title="背包问题IV（完全背包 求方案）"></a>背包问题IV（完全背包 求方案）</h2><p><strong>描述：</strong> 给出 n 个物品, 以及一个数组, <code>nums[i]</code>代表第i个物品的大小, 保证大小均为正数并且没有重复, 正整数 <code>target</code> 表示背包的大小, 找到能填满背包的方案数。<code>每一个物品可以使用无数次</code> </p><p><a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">零钱兑换II</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">backpack_4</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//爬楼梯 零钱兑换II</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">backPackIV_1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>][target + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//target=0时,对于任意硬币来说 都可以不选  所以都为1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">//当前元素不选</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123; <span class="comment">//当前元素选</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                    dp[i][j] += dp[i][j - nums[i - <span class="number">1</span>]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[nums.length][target];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIV_2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123; <span class="comment">//加入第i个元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = nums[i - <span class="number">1</span>]; j &lt;= target; j++) &#123;  <span class="comment">//当前元素可能的组合个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                dp[j] += dp[j - nums[i - <span class="number">1</span>]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[target];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="背包问题V"><a href="#背包问题V" class="headerlink" title="背包问题V"></a>背包问题V</h2><p><strong>描述：</strong> 给出 <code>n</code> 个物品, 以及一个数组, <code>nums[i]</code> 代表第i个物品的大小, 保证大小均为正数, 正整数 <code>target</code> 表示背包的大小, 找到能填满背包的方案数。<code>每一个物品只能使用一次</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">backpack_5</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackV_1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>][target + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">//不选当前元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) &#123; <span class="comment">//选当前元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// 这边+的时i-1 表示 如果选当前元素 之前没选过</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[nums.length][target];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackV_2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 目标为0  当前元素也不选</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i - <span class="number">1</span>]; j--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                dp[j] += dp[j - nums[i - <span class="number">1</span>]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[target];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="背包问题VI（组合问题）"><a href="#背包问题VI（组合问题）" class="headerlink" title="背包问题VI（组合问题）"></a>背包问题VI（组合问题）</h2><p><strong>描述：</strong> 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 </p><p><code>顺序不同的序列被视作不同的组合。</code></p><p><strong>注意与问题IV的区别：</strong>组合考虑元素之间的顺序</p><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener">组合总和IV</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">combinationSum4_377</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//把该问题看成完全背包问题 并且考虑顺序 所以target循环放在外部</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//转移方程：dp[i] = dp[i]+dp[i-num]  i为目标数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 状态转移方程：dp[i]= dp[i - nums[0]] + dp[i - nums[1]] + dp[i - nums[2]] + ... （当 [] 里面的数 &gt;= 0）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 特别注意：dp[0] = 1，表示，如果那个硬币的面值刚刚好等于需要凑出的价值，这个就成为 1 种组合方案</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 再举一个具体的例子：nums=[1, 3, 4], target=7;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * dp[7] = dp[6] + dp[4] + dp[3]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 即：7 的组合数可以由三部分组成，1 和 dp[6]，3 和 dp[4], 4 和dp[3];</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (i &gt;= num) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                    dp[i] += dp[i - num];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[target];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p><strong>描述：</strong>给定<code>n</code>种大小为 <code>A[i]</code>，值为 <code>V[i]</code>的物品，每个物品有 <code>amount[i]</code> 个可用，一个大小为 <code>m</code> 的背包，你能放入背包的最大值是多少?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">backpack_7</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">backpackVII_1</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span>[] amount, <span class="keyword">int</span> m)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length + <span class="number">1</span>][m + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">//dp[i][j] = dp[i - 1][j];</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= amount[i - <span class="number">1</span>]; k++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">//k=0 表示当前元素不选</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (j &gt;= k * A[i - <span class="number">1</span>]) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                        dp[i][j] = Math.max(dp[i][j], </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                                            dp[i - <span class="number">1</span>][j - k * A[i - <span class="number">1</span>]] + k * V[i - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[A.length][m];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">backpackVII_2</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span>[] amount, <span class="keyword">int</span> m)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= A[i - <span class="number">1</span>]; j--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= amount[i - <span class="number">1</span>]; k++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (j &gt;= k * A[i - <span class="number">1</span>]) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                        dp[j] = Math.max(dp[j], dp[j - k * A[i - <span class="number">1</span>]] + k * V[i - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[m];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="多重背包问题变种"><a href="#多重背包问题变种" class="headerlink" title="多重背包问题变种"></a>多重背包问题变种</h2><p><strong>描述：</strong>给出一些不同价值和数量的硬币。 找出这些硬币可以组合在1〜n范围内的多少个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">backpack_8</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//这种解法会超时</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">backpackVIII_1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] V, <span class="keyword">int</span>[] amount)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//状态转移：dp[j] = dp[j]||dp[i-V[i]]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= V.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= amount[i - <span class="number">1</span>]; k++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= V[i - <span class="number">1</span>]; j--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">//dp[j] = dp[j] || dp[j - V[i - 1]];</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (!dp[j] &amp;&amp; dp[j - V[i - <span class="number">1</span>]]) &#123; <span class="comment">//剪枝</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                        dp[j] = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dp.length - <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            System.out.println(dp[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (dp[i]) ans++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//优化 比较难想到</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">backpackVIII_2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] V, <span class="keyword">int</span>[] amount)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= V.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//count数组的含义  相同价值硬币的使用次数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//count[x]即当前i的时候，多少个硬币i已经用了来和其他硬币凑出x的价值。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = V[i - <span class="number">1</span>]; j &lt;= n; j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">//为什么正序遍历？</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">/* 3种剪枝情况</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                1. dp[j]已经为true 无须继续更新</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                2. 加入当前[value]为true，需要保证[j-value]也为true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                3. 硬币使用数量受限</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                * */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (!dp[j] &amp;&amp; dp[j - V[i - <span class="number">1</span>]] &amp;&amp; count[j - V[i - <span class="number">1</span>]] &lt; amount[i - <span class="number">1</span>]) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">                    dp[j] = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">                    count[j] = count[j - V[i - <span class="number">1</span>]] + <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dp.length - <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">            System.out.println(dp[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (dp[i]) ans++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="背包问题IX（01背包问题）"><a href="#背包问题IX（01背包问题）" class="headerlink" title="背包问题IX（01背包问题）"></a>背包问题IX（01背包问题）</h2><p><strong>描述：</strong>你总共有<code>n</code> 万元，希望申请国外的大学，要申请的话需要交一定的申请费用，给出每个大学的申请费用以及你得到这个大学offer的成功概率，大学的数量是 <code>m</code>。如果经济条件允许，你可以申请多所大学。找到获得至少一份工作的最高可能性。<code>0&lt;=n&lt;=10000,0&lt;=m&lt;=10000</code></p><p><strong>样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">样例 1:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输入:  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">n &#x3D; 10</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">prices &#x3D; [4,4,5]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">probability &#x3D; [0.1,0.2,0.3]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">输出:  0.440</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">解释：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">选择第2和第3个学校。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">样例 2:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">输入: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">n &#x3D; 10</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">prices &#x3D; [4,5,6]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">probability &#x3D; [0.1,0.2,0.3]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">输出:  0.370</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">解释:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">选择第1和第3个学校。</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">backpack_9</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 代码思路</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 1. 定义一个二维数组dp[i]来表示花费i万元申请学校一所都没录取的概率</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 2. 初始化dp数组，先假设录取概率都为0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 3. 操作probability数组，变成未录取的概率 probability[i] = 1.0 - probability[i]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 4. 第一层循环枚举i表示申请前i个学校</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 5. 第二层循环枚举j表示花费j万元</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 6. 根据算法思路中的状态转移方程来实现 dp[j] = min(dp[j],dp[j-prices[i]] * probability[i])</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 7. dp[n]表示花费 n 万元一所学校都未录取的最小概率</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//转换成01背包来想： 有n个学校，每个学校都不录取的值为Vi，求一所学校都没录取的最小值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">backpackIX_1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] prices, <span class="keyword">double</span>[] probability)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">double</span>[][] dp = <span class="keyword">new</span> <span class="keyword">double</span>[prices.length + <span class="number">1</span>][n + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= prices.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                dp[i][j] = <span class="number">1.0</span>;  <span class="comment">//初始化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; probability.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            probability[i] = <span class="number">1.0</span> - probability[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= prices.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (j &gt;= prices[i - <span class="number">1</span>]) &#123; <span class="comment">//选择当前学校</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                            dp[i - <span class="number">1</span>][j - prices[i - <span class="number">1</span>]] * probability[i - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">1</span> - dp[prices.length][n];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">backpackIX_2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] prices, <span class="keyword">double</span>[] probability)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[n + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            dp[i] = <span class="number">1.0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; probability.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">            probability[i] = <span class="number">1.0</span> - probability[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= prices.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= prices[i - <span class="number">1</span>]; j--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">                dp[j] = Math.min(dp[j], dp[j - prices[i - <span class="number">1</span>]] * probability[i - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">1</span> - dp[n];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> n = <span class="number">6595</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] prices = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">178</span>, <span class="number">4933</span>, <span class="number">9772</span>, <span class="number">4890</span>, <span class="number">1732</span>, <span class="number">1690</span>, <span class="number">3793</span>&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">double</span>[] weight = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.8</span>&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        System.out.println(backpackIX_1(n, prices, weight));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表双指针：到底该走几步？</title>
      <link href="/2020/08/01/linked-list-cycle/"/>
      <url>/2020/08/01/linked-list-cycle/</url>
      
        <content type="html"><![CDATA[<p>环形链表II和相交链表</p><a id="more"></a><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表I</a></p><p><a href>环形链表II</a></p><p>判断一个链表是否有环，最基本的双指针方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//快慢指针 slow每次走1格 fast每次走2格</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        ListNode slow = head;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(slow.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        ListNode fast = slow.next.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//当快慢指针相遇 说明存在环</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                slow = slow.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(fast.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                fast = fast.next.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//没有环的最终会推出循环</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>但是，如果想要判断环形链表中环的起点时，就要考虑快慢指针走了多少次。</p><p>假设从链表起点出发到环起点的距离为<code>a</code>，环的长度为<code>b</code>，现有快慢指针<code>fast</code>和<code>slow</code>第一次相遇。</p><ul><li><p><code>fast</code> 走的步数是<code>slow</code>步数的 2倍，即<code>f = 2s</code>；</p></li><li><p><code>fast</code>比 <code>slow</code>多走了 n 个环的长度，即<code>f = s + nb</code>；（ <strong>解析</strong>: 双指针都走过<code>a</code>步，然后在环内绕圈直到重合，重合时 <code>fast</code> 比 <code>slow</code> 多走环的长度整数倍 ）</p></li><li><p>以上两式相减得：<code>f = 2nb</code>, <code>s = nb</code></p></li></ul><p>现在考虑环的起点位置为：<code>a+nb</code>，所以， <code>slow</code>指针 <strong>位置不变</strong> ，将<code>fast</code>指针重新 <strong>指向链表头部节点</strong> ；<code>slow</code>和<code>fast</code>同时每轮向前走 <code>a</code> 步，两个结点再次重合，该节点即为环的起点。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        ListNode slow = head, fast = head;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            slow = slow.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (fast==<span class="keyword">null</span>||fast.next == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                fast = fast.next.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        fast = head;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            slow = slow.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            fast = fast.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> slow;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a></p><p>找到两个单链表相交的起始节点，记链表长度分别为<code>a</code>和<code>b</code>，可以考虑<code>fast</code>结点先走 <code>abs(a-b)</code> 步， 然后<code>fast</code>和<code>slow</code>指针在同时往后走直到相交结点。但是获得<code>lenA</code>和<code>lenB</code>需要多次遍历链表。</p><p>现在考虑如何减少遍历的次数。</p><p>设链表<code>A</code>的长度为<code>a</code>，链表<code>B</code>的长度为<code>b</code>，<code>A</code>到相交结点的距离为<code>c</code>,<code>B</code>到相交节点的距离为<code>d</code>。</p><p>显然可以得到两者相交链表的长度：<code>a - c = b - d</code>，</p><p> 变换一下式子得到：<code>a + d = b + c</code>。</p><p>用一个指针从链表<code>A</code>出发，到末尾后就从<code>B</code>出发，用另一个指针从<code>B</code>出发，到末尾后从<code>A</code>出发，</p><p>当前一个指针走了<code>a+d</code>步数时，后一个指针走了<code>b+c</code>,两步数相等，即走到了相交节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        ListNode q = headA, p = headB;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (q != p) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                q = q.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                q = headB;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                p = p.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                p = headA;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树——几种遍历的非递归模板</title>
      <link href="/2020/07/08/binary-tree-traversals/"/>
      <url>/2020/07/08/binary-tree-traversals/</url>
      
        <content type="html"><![CDATA[<p>二叉树遍历的递归代码比较精简，非递归的迭代思路也常常在leetcode中遇到，本文整理了几种非递归的java代码作为模板。</p><a id="more"></a><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历-leetcode-144</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        TreeNode left;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        TreeNode right;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            val = x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        stack.push(root); <span class="comment">//根结点入栈</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        TreeNode p;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            p = stack.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            list.add(p.val);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123; <span class="comment">//右节点先入栈 后出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                stack.push(p.right);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                stack.push(p.left);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历-leetcode-94</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        TreeNode left;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        TreeNode right;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            val = x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        TreeNode p = root;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                stack.push(p);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                p = p.left;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            p = stack.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            ans.add(p.val);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            p = p.right;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">二叉树的后序遍历-leetcode-145</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        TreeNode left;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        TreeNode right;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            val = x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 利用一个指针标记访问过的右子树结点 当访问过右子树在访问根结点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        TreeNode p = root, r = <span class="keyword">null</span>; <span class="comment">//r结点用来表示当前的左孩子是否被访问</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!stack.empty() || p != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                stack.push(p);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                p = p.left;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="comment">//走到最左边的结点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            p = stack.peek();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span> &amp;&amp; p.right != r) &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">//存在右子树并且没有被访问则先访问右子树，否则访问该节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                stack.push(p.right);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                p = p.right;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                p = p.left;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                p = stack.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                list.add(p.val);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                r = p;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                p = <span class="keyword">null</span>; <span class="comment">//让p指针不要乱指</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*前序：根-&gt;左-&gt;右 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    后序：左-&gt;右-&gt;根 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    后序翻转  根-&gt;右-&gt;左 把后序当作前序然后在翻转一次 （不是严格意义的后序遍历）*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal_1</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        stack.push(root);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">            TreeNode p = stack.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">            list.add(<span class="number">0</span>, p.val);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">                stack.push(p.left);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">                stack.push(p.right);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//阿里面试题</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*仅利用栈去判断该节点是否为父结点，创新性思路是每次在栈中压入父节点后压入null节点，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    之后再依次压入右子节点和左子节点。*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal_2</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        stack.push(root);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">            TreeNode p = stack.peek();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">                stack.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">                list.add(stack.pop().val);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">                stack.push(<span class="keyword">null</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">                    stack.push(p.right);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">                    stack.push(p.left);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p><a href>二叉树的层序遍历 (leetcode-102)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        TreeNode left;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        TreeNode right;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            val = x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.借用辅助栈</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        queue.add(root);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> count = queue.size(); <span class="comment">//记录当前层的个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                TreeNode node = queue.poll();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                list.add(node.val); <span class="comment">//当前层的节点加入该list</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                    queue.add(node.left);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                    queue.add(node.right);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                count--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            res.add(list);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//2.递归思路</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder_2(TreeNode root) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        DFS(root, <span class="number">0</span>, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//通过列表的长度来确认是否添加子列表  列表的长度就是二叉树的高度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode p, <span class="keyword">int</span> level, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (ans.size() &lt;= level) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">            ans.add(list);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        ans.get(level).add(p.val);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        DFS(p.left, level + <span class="number">1</span>, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        DFS(p.right, level + <span class="number">1</span>, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路径总和问题</title>
      <link href="/2020/07/05/pathSum/"/>
      <url>/2020/07/05/pathSum/</url>
      
        <content type="html"><![CDATA[<p>关于leetcode中路径总和的几道题目的整理。</p><a id="more"></a><h2 id="路径总和I"><a href="#路径总和I" class="headerlink" title="路径总和I"></a>路径总和I</h2><ul><li><p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">leetcode112</a></p></li><li><p>题目描述： 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 </p></li><li><p>解题思路：递归，sum值每次递归减去其根结点的值</p></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        sum -= root.val; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> sum == <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum) || hasPathSum(root.right, sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul><h2 id="路径总和II"><a href="#路径总和II" class="headerlink" title="路径总和II"></a>路径总和II</h2><ul><li><p><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">leetcode113，剑指offer34</a></p></li><li><p>题目描述： 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 </p></li><li><p>解题思路：递归，利用一个数组保存遍历的路径，如果遇到根结点并且满足条件则输出。</p></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        List&lt;Integer&gt; arry = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        dfs(root, sum, arry, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, List&lt;Integer&gt; arry, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        arry.add(root.val);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        sum -= root.val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//ans.add(arry); //整个递归过程用的是同一个arry，需要把当前的状态保存下来，否则最后的输出全为空[]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(arry));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        dfs(root.left, sum, arry, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        dfs(root.right, sum, arry, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        arry.remove(arry.size() - <span class="number">1</span>);<span class="comment">//回溯，去除当前的根结点，继续寻找下一个满足条件的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul><h2 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a>路径总和III</h2><ul><li><p><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">leetcode437</a></p></li><li><p>题目描述：给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p></li><li><p>解题思路：</p><ul><li>思路1：递归，从每一个节点出发，找到所有满足条件的路径，两层递归。</li><li>思路2：考虑到每个节点到根节点的路径是唯一的。用一维数组保存当前节点到根节点的所有路径，用一个标记表示当前路径的终点。</li></ul></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//思路1 双重递归</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//先序遍历每一个结点，在以每一个节点作为起始节点递归查找</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        cal_sum(root, sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        pathSum(root.left, sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        pathSum(root.right, sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//计算当前结点作为根结点的所有满足的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal_sum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        sum -= root.val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            num++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        cal_sum(root.left, sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        cal_sum(root.right, sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="comment">//思路2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**核心：每个节点到根节点的路径是唯一的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * 1.用一维数组保存当前节点到根节点的所有路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * 2.用一个标记表示当前路径的终点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * 3.先序遍历所有节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> cal_sum(root, sum, <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>], <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//arry数组用于保存遍历过的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal_sum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> arry[], <span class="keyword">int</span> p)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> n = (root.val == sum ? <span class="number">1</span> : <span class="number">0</span>); <span class="comment">//判断单独的节点是否满足条件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> cur = root.val; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//根结点出发到当前结点的所有可能值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            cur += arry[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (cur == sum) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                n++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        arry[p] = root.val; <span class="comment">//访问过的结点加入数组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> n1 = cal_sum_2(root.left, sum, arry, p + <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> n2 = cal_sum_2(root.right, sum, arry, p + <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> n + n1 + n2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识图卷积网络</title>
      <link href="/2020/01/08/GCN/"/>
      <url>/2020/01/08/GCN/</url>
      
        <content type="html"><![CDATA[<p>GCN的初学笔记</p><a id="more"></a><p><a href="https://programtip.com/zh/art-45551" target="_blank" rel="noopener">关于卷积神经网络的一些理解</a></p><p><a href="https://www.zhihu.com/question/54504471/answer/332657604" target="_blank" rel="noopener">如何理解 Graph Convolutional Network（GCN）？</a></p><p><a href="https://arxiv.org/pdf/1609.02907.pdf" target="_blank" rel="noopener"> SEMI-SUPERVISED CLASSIFICATION WITH GRAPH CONVOLUTIONAL NETWORKS </a></p><p><a href="https://www.jianshu.com/p/0d27f0816c09" target="_blank" rel="noopener">图神经网络(GCN)</a></p>]]></content>
      
      
      <categories>
          
          <category> GCN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> GCN </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划——子序列和回文串问题</title>
      <link href="/2019/12/15/max-subsequence/"/>
      <url>/2019/12/15/max-subsequence/</url>
      
        <content type="html"><![CDATA[<p>动态规划中关于子序列，回文串的几道题整理了一下。</p><a id="more"></a><h3 id="最长子序列"><a href="#最长子序列" class="headerlink" title="最长子序列"></a>最长子序列</h3><ul><li><p>问题：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p></li><li><p>DP思路：（非最优解）</p><p>记<code>s(i)</code>，<code>t(j)</code>分别为长度为 i，j 的字符串 s 和字符串 t 。</p><p>如果<code>s[i-1]==t[j-1]</code>，最后一位相同，继续比较<code>s[i-2]</code>和<code>t[j-2]</code>，</p><p>如果<code>s[i-1]!=t[j-1]</code>，最后一位不同，比较<code>s[i-1]</code>和<code>t[j-2]</code>，</p><p>使用一个二维数组d保存子序列的状态，</p><p>时间复杂度：<code>O(m*n)</code></p><p>空间复杂度：<code>O(m*n)</code></p></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">boolean</span>[][] d = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">if</span> (s.length() &gt; t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t.length(); j++) &#123; <span class="comment">//s长度为0时，一定是t的子序列</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">              d[<span class="number">0</span>][j] = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.length(); j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                  <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;  <span class="comment">//如果当前的最后一位相同 比较s的前一位和t的前一位</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                      d[i][j] = d[i - <span class="number">1</span>][j - <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                      d[i][j] = d[i][j - <span class="number">1</span>]; <span class="comment">//否则比较s和t的前一位</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">return</span> d[s.length()][t.length()];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="/2019/12/15/max-subsequence/isSubsequence.png" alt></p><p>其他思路参考： <a href="https://github.com/xiaomindog/leetcode/blob/master/java_leetcode/src/com/leetcode/easy/isSubsequence_392.java" target="_blank" rel="noopener">isSubsequence_392</a></p><p>空间复杂度可以继续优化，待更新。</p></li></ul><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><ul><li><p>问题：给定一个字符串 s，找到 s 中最长的回文子串。</p></li><li><p>DP思路：（目前想到的最优解）</p><ul><li><p>中心扩展法</p><p>遍历字符串序列，遍历到第i个字符串，以i字符串为中心，向左右扩展回文串，每次保存最大长度的开始和结束坐标。需要注意的细节是，子串长度为1和2时要单独处理，具体看代码。</p><p>这里中心的个数一般会错误认为是n，实际上是2n-1，因为2个字母中间的空格，在回文子串长度为偶数时是作为中心的。</p><p> 时间复杂度：<code>O(n^2)</code></p><p> 空间复杂度：<code>O(1)</code></p></li></ul></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//按中心展开 共有2n-1个中心 如果字母数为偶数，每2个元素之间的空格也要算为1个中心</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> len1 = expend_from_center(s, i, i); <span class="comment">// 考虑单个字母时候的len</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> len2 = expend_from_center(s, i, i + <span class="number">1</span>); <span class="comment">//考虑2个字母为回文时候的len</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);  <span class="comment">//保存较长的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (len &gt; end - start) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                end = i + len / <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> s.substring(start, end+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//以某个字母向两边扩展</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expend_from_center</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> ((left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            left--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            right++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="/2019/12/15/max-subsequence/longestPalindrome.png" alt></p></li></ul><h3 id="回文子串个数"><a href="#回文子串个数" class="headerlink" title="回文子串个数"></a>回文子串个数</h3><ul><li><p>问题： 给定一个字符串，计算这个字符串中有多少个回文子串。 </p></li><li><p>DP思路：</p><p>中心扩展法，思路同最长回文子串，基本只要加个计数器即可。</p><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(1)</code></p></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length(); i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            count(s, i, i);<span class="comment">//单个字母肯定是回文，只做了一次num++</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            count(s, i, i+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span>(start &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.length() &amp;&amp; s.charAt(start) == s.charAt(end))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            num++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            start--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            end++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="/2019/12/15/max-subsequence/countSubstrings.png" alt></p></li></ul><h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><ul><li><p>问题：给定一个字符串 s，找到其中最长的回文子序列。 </p></li><li><p>DP思路：</p><p>用二维数组<code>dp[n][n]</code>表示长度为 n 的字符串 s 的状态矩阵，<code>dp[i][j]</code>表示 i 到 j 之间字符串最长  回文子序列长度，</p><p>状态转移方程：</p><p>如果 <code>s[i]==s[j]</code>：<code>dp[i][j]=dp[i+1][j-1]+2</code></p><p>如果 <code>s[i]!=s[j]</code>：<code>dp[i][j]=MAX(dp[i+1][j],dp[i][j+1])</code></p><p>注意：i 要从后往前遍历</p><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(n^2)</code></p></li><li><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//动态规划 二维数组作为状态矩阵 下三角稀疏 可优化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()][s.length()];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//想清楚为什么从后往前遍历 保证了i,j之间的子序列的状态的更新</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            dp[i][i] = <span class="number">1</span>;<span class="comment">//单个字母的最长回文子序列一定是1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                    dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//输出dp数据测试</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//        for (int i = 0; i &lt; s.length(); i++) &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//            for (int j = 0; j &lt; s.length(); j++) &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//                System.out.print(dp[i][j]);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//            &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//            System.out.println();</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//        &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.length() - <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="/2019/12/15/max-subsequence/longestPalindromeSubseq1.png" alt></p></li><li><p>压缩二维矩阵为一维矩阵，空间复杂度为<code>O(n)</code> 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//二维数据降为一维数组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()]; <span class="comment">// 前一步状态矩阵</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()]; <span class="comment">//当前状态矩阵 最后一个元素永远保存当前的最大回文子序列长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            cur[i] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    cur[j] = pre[j - <span class="number">1</span>] + <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                    cur[j] = Math.max(pre[j], cur[j - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span>[] temp = pre;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            pre = cur;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            cur = temp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> pre[s.length() - <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="/2019/12/15/max-subsequence/longestPalindromeSubseq2.png" alt></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo如何在不同电脑上写博客</title>
      <link href="/2019/12/08/hexo%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E4%B8%8A%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/12/08/hexo%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E4%B8%8A%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>如果要更换电脑了发现电脑里没有原来的博客文件怎么办，这时候就可以利用git的分支保存我们博客的相关文件，每次更新都上传到分支去，更换电脑只需git clone下来即可。</p><a id="more"></a><h3 id="上传分支"><a href="#上传分支" class="headerlink" title="上传分支"></a>上传分支</h3><ul><li><p>先在github博客仓库中创建一个分支，在<code>settings</code>中设置<code>hexo</code>分支为默认分支，仓库克隆至本地目录</p></li><li><p>复制原来第一次写博客配置的那些文件（除了<code>.deploy_git</code>）。注意，需要把theme目录下的<code>.git</code>文件删除。</p></li><li><p>把配置相关内容上传博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">git add . </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">git commit -m "add hexo branch"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">git push</span></pre></td></tr></table></figure><p>这一步如果出现错误<code>warning: LF will be replaced by CRLF</code>，可在该目录下添加文件<code>.gitattributes</code>文件，内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># Auto detect text files and perform LF normalization</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">*        text&#x3D;auto</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">*.cs     text diff&#x3D;csharp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">*.java   text diff&#x3D;java</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">*.html   text diff&#x3D;html</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">*.css    text</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">*.js     text</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">*.sql    text</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">*.csproj text merge&#x3D;union</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">*.sln    text merge&#x3D;union eol&#x3D;crlf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">*.docx   diff&#x3D;astextplain</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">*.DOCX   diff&#x3D;astextplain</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"># absolute paths are ok, as are globs</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#x2F;**&#x2F;postinst* text eol&#x3D;lf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"># paths that don&#39;t start with &#x2F; are treated relative to the .gitattributes folder</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">relative&#x2F;path&#x2F;*.txt text eol&#x3D;lf</span></pre></td></tr></table></figure><p>具体细节参考：<a href="![img](file:///C:\Users\cm\AppData\Roaming\Tencent\QQ\Temp\%W@GJ$ACOF(TYDYECOKVDYB.png">使用git最好的CRLF（回车，换行处理策略是什么？）</a><a href="https://stackoverflow.com/questions/170961/whats-the-best-crlf-carriage-return-line-feed-handling-strategy-with-git" target="_blank" rel="noopener">https://stackoverflow.com/questions/170961/whats-the-best-crlf-carriage-return-line-feed-handling-strategy-with-git</a> )，stackoverflow需翻墙，应该可以成功，如果不行尝试其他办法吧。</p></li></ul><h3 id="更换电脑后操作"><a href="#更换电脑后操作" class="headerlink" title="更换电脑后操作"></a>更换电脑后操作</h3><ul><li><p>安装原来需要的环境，创建github链接等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git</span></pre></td></tr></table></figure><p>这条命令执行完后目录中会生成node_modules和public文件夹，这是原来上传的时候忽略上传的内容</p></li><li><p>然后可以开始正常写博客了，<code>hexo n &quot;XXX&quot;</code></p></li><li><p>注意：</p><p>如果更新了博客的配置，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">git add . </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  git commit -m "modify xxx"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  git push</span></pre></td></tr></table></figure><p>更新博客配置到GitHub上以备份。</p></li></ul><h3 id="设置SSH使用hexo-d时免输用户名密码"><a href="#设置SSH使用hexo-d时免输用户名密码" class="headerlink" title="设置SSH使用hexo d时免输用户名密码"></a>设置SSH使用hexo d时免输用户名密码</h3><ul><li>参考：( <a href="https://blog.csdn.net/hhgggggg/article/details/77853665" target="_blank" rel="noopener">https://blog.csdn.net/hhgggggg/article/details/77853665</a> )</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于kashgari+BERT的命名实体识别（NER）</title>
      <link href="/2019/12/06/%E5%9F%BA%E4%BA%8Ekashgari-BERT%E7%9A%84%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB%EF%BC%88NER%EF%BC%89/"/>
      <url>/2019/12/06/%E5%9F%BA%E4%BA%8Ekashgari-BERT%E7%9A%84%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB%EF%BC%88NER%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近帮师兄做NER的BIO标注进行触发词识别的对比实验，用到了一个很好的框架<a href="https://github.com/BrikerMan/Kashgari" target="_blank" rel="noopener">kashgari</a>，基于 tf.keras编写，使用起来很方便，几分钟即可搭建一个文本分类/命名实体识别的baseline。对于命名实体识别任务，该框架封装了BiLSTM，BiGRU，BiLSTM+CRF，BiGRU+CRF，CNN_LSTM。可加载wordembedding和bert词向量。</p><a id="more"></a><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">pip install tensorflow&#x3D;&#x3D;1.14</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">pip install kashgari-tf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">python3.6</span></pre></td></tr></table></figure><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>NER标签采用BIO标注的形式。</p><p>train_x和 train_y，test_x和test_y都是list类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">train_x: [[char1],[char1],[char1],..... ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">train_y: [[label1],[label2],[label3],..... ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#eg:bert基于字级别的BIO数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">train_x = [[<span class="string">'立'</span>,<span class="string">'法'</span>,<span class="string">'院'</span>,<span class="string">'成'</span>,<span class="string">'立'</span>,<span class="string">'刺'</span>,<span class="string">'激'</span>,<span class="string">'团'</span>,<span class="string">'体'</span>],...]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">train_y = [[<span class="string">'B-ORG'</span>,<span class="string">'I-ORG'</span>,<span class="string">'I-ORG'</span>,<span class="string">'O'</span>,<span class="string">'O'</span>,<span class="string">'O'</span>,<span class="string">'O'</span>,<span class="string">'O'</span>,<span class="string">'O'</span>],...]</span></pre></td></tr></table></figure><h3 id="导入模型，加载预训练embedding"><a href="#导入模型，加载预训练embedding" class="headerlink" title="导入模型，加载预训练embedding"></a>导入模型，加载预训练embedding</h3><p><a href="https://github.com/google-research/bert" target="_blank" rel="noopener">BERT-Base, Chinese</a></p><p><a href="https://github.com/Embedding/Chinese-Word-Vectors" target="_blank" rel="noopener">Chinese-Word-Vectors</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kashgari</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kashgari.tasks.labeling <span class="keyword">import</span> BiLSTM_CRF_Model, BiGRU_CRF_Model</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kashgari.embeddings <span class="keyword">import</span> BERTEmbedding, WordEmbedding</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">BERT_PATH = <span class="string">'./data/chinese_L-12_H-768_A-12'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">bert_embedding=BERTEmbedding(BERT_PATH,task=kashgari.LABELING,sequence_length=<span class="number">100</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果加载wordembedding的词向量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#word_embedding = WordEmbedding(embed_path, task=kashgari.LABELING, sequence_length=100)</span></span></pre></td></tr></table></figure><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">model = BiLSTM_CRF_Model(embedding)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">model.fit(train_x, train_y,x_validate=val_x, y_validate=val_y,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">          epochs=<span class="number">40</span>,batch_size=<span class="number">128</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果没有开发集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#model.fit(train_x, train_y,epochs=40,batch_size=128)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">model.evaluate(test_x, test_y)</span></pre></td></tr></table></figure><h3 id="实验结果及代码"><a href="#实验结果及代码" class="headerlink" title="实验结果及代码"></a>实验结果及代码</h3><p>实验证明BERT+BiLSTM+CRF取得的效果是最好的。完整代码待上传github。</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> NER </tag>
            
            <tag> bert </tag>
            
            <tag> kashgari </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人博客</title>
      <link href="/2019/12/06/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/12/06/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>搭建简易的hexo博客过程，一些自己常用设置和相关操作</p><a id="more"></a><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><ul><li>git</li><li>nodejs</li><li>hexo</li><li>创建github同名的仓库</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li><p><code>hexo init</code> hexo自动下载一些文件到目录</p></li><li><p><code>hexo g</code> 生成静态文件  hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github上</p></li><li><p><code>hexo s</code> 本地预览 打开浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到内容，<code>Ctrl+C</code>停止本地预览</p></li><li><p>设置主题 打开_config.yml 找到theme字段： 添加主题next</p></li><li><p>配置站点配置文件_config.yml deploy的部分. 安装部署插件  <code>npm install hexo-deployer-git</code>  <code>hexo d</code> 部署到github上 最后打开即可显示内容</p></li></ul><h3 id="主题相关配置"><a href="#主题相关配置" class="headerlink" title="主题相关配置"></a>主题相关配置</h3><ul><li><p>主题风格 ：编辑schemes字段。 更新主题风格 <code>hexo clean,hexo g, hexo d</code></p></li><li><p>设置Menu：编辑menu字段。</p></li><li><p>修改文章内链接文本样式：themes/next/source/css/_common/components/post/post.styl，在末尾添加CSS样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  color: #0593d3; //原始链接颜色</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  border-bottom: 1px solid #0593d3; //底部分割线颜色</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    color: #fc6423; //鼠标经过颜色</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    border-bottom: 1px solid #fc6423; //底部分割线颜色</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li><li><p>设置头像：编辑url字段 添加图片链接</p></li><li><p>社交栏：编辑social字段 <code>[社交平台名]: [社交地址] || [图标名称]</code></p></li><li><p>设置首页不显示全文(只显示预览)：markdown文本中添加<code>&lt;!--more--&gt;</code></p></li><li><p>分类和标签设置 <code>hexo new page &quot;name&quot;</code>  可在yourBlog\source\“name”\index.md继续编辑内容</p><p>scaffolds/post.md文件下可设置新建文件的模板</p></li><li><p>搜索功能：待添加</p></li><li><p>修改分类标签样式：<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 # 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p></li><li><p>菜单栏图标设置：<a href="https://icomoon.io/#preview-essential" target="_blank" rel="noopener">icomoon</a>找到想要的图标即可</p></li><li></li></ul><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
