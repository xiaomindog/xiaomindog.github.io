---
title: Pre-trained Models for Natural Language Processing: A survey
date: 2021-01-20 10:59:50
tags: [NLP,deeplearning]
categories: [deeplearning]
mathjax: true
---

该文通过四种分类维度来划分目前已有的预训练模型。包括：

- **「表征的类型」**,即：学习到的表征是否是上下文感知的。

- **「编码器结构」**,如：LSTM、Transformer；

- **「预训练任务类型」**,如LM，MLM，PLM；

- **「针对特定场景的拓展」**,如跨语言预训练，知识增强，多模态预训练，模型压缩等。

  <!--more-->

###  1. 表征的类型

- 非上下文感知

  非上下文感知的词语表示是静态的，无法解决一词多义问题和OOV问题（Word2Vec），这种情况下一般只能通过character-level或者sub-word embedding来解决，即通过拆解词粒度为字符粒度来解决泛化性问题。

  这一类的代表性工作包括：**「NNLM」**,**「word2vec」**,**「GloVe」**。

- 上下文感知

  词语会随着词所在的上下文不同而动态变化，能够解决一词多义问题。token的表示需要依赖于整个文本。

  - 利用特征抽取器来产生上下文词嵌入表示

    代表性工作：
    (1) **「CoVe」：**用带注意力机制的seq2seq从机器翻译任务中预训练一个LSTM encoder。输出的上下文向量(CoVe)有助于提升一系列NLP下游任务的性能。
    (2) **「ELMo」：** 用两层的Bi-LSTM从双向语言模型任务BiLM（包括1个前向的语言模型以及1个后向的语言模型）中预训练一个**Bi-LSTM Encoder**。能够显著提升一系列NLP下游任务的性能。

  - 微调

    代表性工作：

    (1) **「ULMFiT」：** 通过在文本分类任务上微调预训练好的语言模型达到了state-of-the-art结果。这篇也预训练模型微调模式的开创性工作。提出了3个阶段的微调：在通用数据上进行语言模型的预训练来学习通用语言特征；在目标任务所处的领域特定的数据上进行语言模型的微调来学习领域特征；在目标任务上进行微调。
    (2) **「GPT」：**使用单向的Transformer预训练单向语言模型。单向的Transformer里头用到了masked self-attention的技巧（相当于是Transformer原始论文里头的Decoder结构），即当前词只能attend到前面出现的词上面。之所以只能用单向transformer，主要受制于单向的预训练语言模型任务，否则会造成信息泄露。

    (3) **「BERT」：**使用双向Transformer作为Encoder（即Transformer中的Encoder结构)，引入了新的预训练任务，带mask的语言模型任务MLM和下一个句子预测任务NSP。由于MLM预训练任务的存在，使得Transformer能够进行**「双向」**self-attention。

###  2. 上下文编码器架构

- 卷积（TextCNN）

- 序列（Bi-LSTM）

- 图模型

  Transformer也是一种图网络的特例：句子中的词构成一张全连接图，图中任意两个词之间都有连边，连边的权重衡量了词之间的关联，通过self-attention来动态计算，目标是让模型自动学习到图的结构（实际上，图上的结点还带了词本身的属性信息，如位置信息等）

###  3. 预训练任务

监督学习，无监督学习，自监督学习

自监督学习：核心思想是，用输入数据的一部分信息以某种形式去预测其另一部分信息。例如BERT中使用的MLM，输入数据是句子，通过句子中其它部分的单词信息来预测一部分masked的单词信息。-

- 语言模型（LM）

  语言模型是指一类能够求解句子概率的概率模型，通常通过概率论中的链式法则来表示整个句子各个单词间的联合概率。链式求导法则的关键特点和原理是**当前词的表示依赖于前面的单词（单向的自回归的）**。

- 带掩码的语言模型（MLM）

  MLM主要是从BERT开始流行起来的，能够解决单向的LM的问题，进行双向的信息编码。

  MLM存在的缺点：

  - 会造成pre-training和fine-tuning之间的gap。[MASK]特殊字符不会出现在fine-tuning阶段出现
  - MLM收敛的速度比较慢
  - MLM不是标准的语言模型，其有着自己的独立性假设，即假设mask词之间是相互独立的。
  - 自回归LM模型能够通过联合概率的链式法则来计算句子的联合概率，而MLM只能进行**「联合概率的有偏估计」**(mask之间没有相互独立)

  增强版MLM：

  - **RoBERTa：**改进了BERT种静态masking的方法，采用了动态masking的方法。
  - **UniLM：**拓展mask prediction任务到三种语言模型任务中，单向预测、双向预测、seq2seq预测。
  - **XLM：**将MLM应用到翻译语言模型中，即“双语料句子对“构成一个句子，然后使用MLM。
  - **SpanBERT：**使用了span masking来随机掩盖一段连续的词。同时额外提出了一种**边界学习目标** ，希望被掩盖的词能够融入边界的信息，即基于边界之外的两个单词的向量和masked单词的位置向量来预测masked单词。
  - **ERNIE：**将外部知识融入到MLM中。引入了命名实体外部知识来掩盖实体单元，进行训练。

- 排列语言模型（PLM）

  PLM在**XLNet**中被提出。动机来源：预训练和微调阶段的gap，mask词之间的独立性假设等。

  在传统的单向自回归语言模型LM中，句子的联合概率因子分解是按照从左到右或者从右到左的方式分解成条件概率的链式乘积的，这可以看作是其中两种联合概率的因子分解序。实际上，句子的联合概率的因子分解序还可以有很多种，可以任意的排列组合进行因子分解。PLM就是对联合概率进行因子分解得到排列，分解得到的排列只决定了模型自回归时的预测顺序，不会改变原始文本序列的自然位置。即：PLM只是针对语言模型建模不同排列下的因子分解排列，并不是词的位置信息的重新排列。

  - XLNet

    XLNet在输入阶段并没有改变输入顺序，随机打乱输入句子的顺序这个过程是在Transformer中通过**Attention mask**实现的，就是随机掩盖掉序列中的一些单词，并将未掩盖掉的单词作为预测单词的上文。

###  自回归与自编码模型

- 自回归（GPT, XLNet, EMLo）

  根据上文内容预测下一个单词，或者根据下文预测前面的单词，这种类型的LM被称为自回归语言模型。

  自回归语言模型有优点有缺点，优点是自然地引入上下文信息，并且解决**自编码语言模型**两阶段保持一致的问题。缺点是只能利用上文或者下文的信息，不能同时利用上文和下文的信息（ELMo融合方式过于简单所以效果不好）。

- 自编码（BERT）

  

###  Reference

[2020最新NLP预训练模型综述](https://zhuanlan.zhihu.com/p/317260710)

[XLNet:运行机制及和Bert的异同比较](https://zhuanlan.zhihu.com/p/70257427)